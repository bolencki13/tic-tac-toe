{"version":3,"mappings":"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","names":["REACT_ELEMENT_TYPE","REACT_FRAGMENT_TYPE","jsxProd","type","config","maybeKey","key","propName","reactJsxRuntime_production","jsxRuntimeModule","require$$0","hasWinningMove","board","player","lines","a","b","c","cells","playerCells","cell","emptyCells","hasForkMove","i","testBoard","winningPaths","evaluateLimitedModePosition","aiPlayer","humanPlayer","aiMoves","humanMoves","maxMovesPerPlayer","aiOldestMove","humanOldestMove","controlScore","evaluateControlScore","removalImpact","simulatedBoard","evaluateImpactOfRemoval","score","aiCount","humanCount","emptyCount","corners","corner","originalBoard","boardAfterRemoval","playerLosing","playerGaining","originalControl","LEARNING_RATE","MIN_OBSERVATIONS","conditionalProbabilities","priorDistribution","serializeBoard","getNormalizedBoardState","orientations","rot90","rot180","rot270","flipH","flipV","flipD1","flipD2","mapMoveToOrientation","move","fromOrientation","toOrientation","transformations","transform","inverseTransform","_","idx","v","observeMove","moveIndex","boardCopy","normalizedState","normalizedMove","conditionalProb","newProb","sum","prob","predictOpponentMove","bestMove","highestProb","probability","originalMove","getBayesianCounterMove","prediction","resetBayesianModel","loadBayesianState","data","pattern","moveProbabilities","moveProb","error","getBayesianStats","state","EXPLORATION_PARAMETER","DEFAULT_ITERATIONS","MAX_TIME_MS","createNode","parent","moves","playerSymbol","selectChild","node","bestScore","bestChild","child","exploitation","exploration","expand","nextState","nextMoves","getAvailableMoves","nextPlayer","childNode","simulate","currentPlayer","availableMoves","winner","checkWinner","backpropagate","result","current","index","findBestMoveMCTS","iterations","winningMove","blockingMove","rootNode","startTime","iterationsCompleted","mostVisits","strategies","currentStrategy","sampleBeta","alpha","beta","u","x","y","selectStrategy","bestStrategy","highestSample","stats","name","sample","updateStrategyPerformance","strategy","recordGameOutcome","aggressiveStrategy","opponent","forkMove","bestCorner","sides","defensiveStrategy","opponentForkMove","lowestOpponentScore","opponentScore","cornersStrategy","cornerPreference","centerStrategy","cornerPairs","c1","c2","randomStrategy","getStrategyMove","gameStyle","xMoves","oMoves","findBestMove","bayesianMove","getAdaptiveStrategyMove","getBanditStats","resetBandit","loadBanditState","savedStrategy","STORAGE_KEY_PREFIX","BANDIT_STORAGE_KEY","BAYESIAN_STORAGE_KEY","TIMESTAMP_STORAGE_KEY","LEARNING_VERSION","saveLearnedData","banditData","bayesianData","stateToSave","loadLearnedData","banditDataStr","bayesianDataStr","parsedBanditData","parsedBayesianData","banditStrategies","banditModule","bayesianModel","bayesianModule","parseError","resetLearnedData","getLearningStats","banditStats","bayesianStats","persistenceInfo","timestampData","initializeAutosave","initializePersistentLearning","aiInitialized","initializeAdvancedAI","recordPlayerMoveAdvanced","recordGameResultAdvanced","findBestMoveAdvanced","difficulty","useGameState","props","mode","style","onGameEnd","setBoard","useState","isXNext","setIsXNext","setWinner","isAIThinking","setIsAIThinking","setXMoves","setOMoves","highlightCell","setHighlightCell","winningLine","setWinningLine","MAX_MOVES_PER_PLAYER","calculateWinner","useCallback","squares","line","resetGame","initialMove","newBoard","updatedBoard","makeAIMove","square","findRandomMove","oldestMoveIndex","prevMoves","useEffect","handleClick","currentMoves","isDraw","Confetti","confettiElements","setConfettiElements","elements","colors","distance","angle","randomX","randomY","animationDelay","randomSpeed","sizes","sizeRoll","size","rotateAmount","color","shapeTypes","shape","jsx","timer","Square","memo","value","onClick","isHighlighted","isWinningSquare","squareClassName","renderSymbol","jsxs","Board","onSquareClick","renderSquare","Status","statusText","WinningLine","TicTacToe","handleSquareClick"],"ignoreList":[0,1],"sources":["../../node_modules/react/cjs/react-jsx-runtime.production.js","../../node_modules/react/jsx-runtime.js","../../src/utils/boardEvaluator.ts","../../src/utils/bayesianModel.ts","../../src/utils/monteCarlo.ts","../../src/utils/banditStrategies.ts","../../src/utils/persistentLearning.ts","../../src/utils/advancedAI.ts","../../src/hooks/useGameState.ts","../../src/components/Confetti/index.tsx","../../src/components/TicTacToe/Square.tsx","../../src/components/TicTacToe/Board.tsx","../../src/components/TicTacToe/Status.tsx","../../src/components/TicTacToe/WinningLine.tsx","../../src/components/TicTacToe/TicTacToe.tsx"],"sourcesContent":["/**\n * @license React\n * react-jsx-runtime.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n  REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\nfunction jsxProd(type, config, maybeKey) {\n  var key = null;\n  void 0 !== maybeKey && (key = \"\" + maybeKey);\n  void 0 !== config.key && (key = \"\" + config.key);\n  if (\"key\" in config) {\n    maybeKey = {};\n    for (var propName in config)\n      \"key\" !== propName && (maybeKey[propName] = config[propName]);\n  } else maybeKey = config;\n  config = maybeKey.ref;\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key,\n    ref: void 0 !== config ? config : null,\n    props: maybeKey\n  };\n}\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsxProd;\nexports.jsxs = jsxProd;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n","/**\n * Advanced board evaluation utilities for Tic Tac Toe AI\n */\nimport type { Board } from './gameTypes';\n\n/**\n * Scores for different board positions/states\n */\nexport const SCORES = {\n  WIN: 100,       // Winning position\n  BLOCK_WIN: 90,  // Blocking opponent's win\n  FORK: 80,       // Creating a fork (two winning paths)\n  BLOCK_FORK: 70, // Blocking opponent's fork\n  CENTER: 60,     // Taking the center\n  CORNER: 50,     // Taking a corner\n  SIDE: 40,       // Taking a side\n  SETUP: 30,      // Setting up potential win\n  NEUTRAL: 0      // Neutral move\n};\n\n/**\n * Evaluates if a player has a winning position on the board\n */\nexport function hasWinningMove(board: Board, player: string): number | null {\n  const lines = [\n    [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows\n    [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns\n    [0, 4, 8], [2, 4, 6]             // diagonals\n  ];\n\n  for (const [a, b, c] of lines) {\n    // Check if player can win in this line\n    const cells = [board[a], board[b], board[c]];\n    const playerCells = cells.filter(cell => cell === player).length;\n    const emptyCells = cells.filter(cell => cell === null).length;\n\n    if (playerCells === 2 && emptyCells === 1) {\n      // Found a winning move, return the empty cell index\n      if (board[a] === null) return a;\n      if (board[b] === null) return b;\n      if (board[c] === null) return c;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Checks if a player has a fork opportunity (two potential winning paths)\n * Returns the move that creates the fork\n */\nexport function hasForkMove(board: Board, player: string): number | null {\n  // Try each empty space\n  for (let i = 0; i < board.length; i++) {\n    if (board[i] !== null) continue;\n\n    // Make a hypothetical move\n    const testBoard = [...board];\n    testBoard[i] = player;\n\n    // Count how many winning opportunities this creates\n    let winningPaths = 0;\n    const lines = [\n      [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows\n      [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns\n      [0, 4, 8], [2, 4, 6]             // diagonals\n    ];\n\n    for (const [a, b, c] of lines) {\n      const cells = [testBoard[a], testBoard[b], testBoard[c]];\n      const playerCells = cells.filter(cell => cell === player).length;\n      const emptyCells = cells.filter(cell => cell === null).length;\n\n      // This line has a winning opportunity\n      if (playerCells === 2 && emptyCells === 1) {\n        winningPaths++;\n      }\n    }\n\n    // If this move creates two or more winning paths, it's a fork\n    if (winningPaths >= 2) {\n      return i;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Advanced evaluation function for board positions in limited game mode\n */\nexport function evaluateLimitedModePosition(\n  board: Board,\n  aiPlayer: string,\n  humanPlayer: string,\n  aiMoves: number[],\n  humanMoves: number[],\n  maxMovesPerPlayer: number\n): number {\n  // The oldest move of each player (will be removed next)\n  const aiOldestMove = aiMoves.length >= maxMovesPerPlayer ? aiMoves[0] : -1;\n  const humanOldestMove = humanMoves.length >= maxMovesPerPlayer ? humanMoves[0] : -1;\n\n  // Calculate control scores\n  const controlScore = evaluateControlScore(board, aiPlayer, humanPlayer);\n\n  // Special cases for limited mode\n  // Evaluate the impact of losing the oldest move\n  let removalImpact = 0;\n\n  if (aiOldestMove !== -1) {\n    const simulatedBoard = [...board];\n    simulatedBoard[aiOldestMove] = null;\n    // How bad would it be if our oldest move is removed?\n    removalImpact -= evaluateImpactOfRemoval(board, simulatedBoard, aiPlayer, humanPlayer);\n  }\n\n  if (humanOldestMove !== -1) {\n    const simulatedBoard = [...board];\n    simulatedBoard[humanOldestMove] = null;\n    // How good would it be if opponent's oldest move is removed?\n    removalImpact += evaluateImpactOfRemoval(board, simulatedBoard, humanPlayer, aiPlayer);\n  }\n\n  return controlScore + removalImpact;\n}\n\n/**\n * Evaluates how much control of the board each player has\n */\nfunction evaluateControlScore(board: Board, aiPlayer: string, humanPlayer: string): number {\n  let score = 0;\n  const lines = [\n    [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows\n    [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns\n    [0, 4, 8], [2, 4, 6]             // diagonals\n  ];\n\n  for (const [a, b, c] of lines) {\n    const cells = [board[a], board[b], board[c]];\n    const aiCount = cells.filter(cell => cell === aiPlayer).length;\n    const humanCount = cells.filter(cell => cell === humanPlayer).length;\n    const emptyCount = cells.filter(cell => cell === null).length;\n\n    // AI has control of this line\n    if (aiCount > 0 && humanCount === 0) {\n      score += 10 * aiCount;\n    }\n\n    // Human has control of this line\n    if (humanCount > 0 && aiCount === 0) {\n      score -= 10 * humanCount;\n    }\n\n    // Special case: two in a row with an empty\n    if (aiCount === 2 && emptyCount === 1) {\n      score += 30; // Near win\n    }\n\n    if (humanCount === 2 && emptyCount === 1) {\n      score -= 30; // Near loss\n    }\n  }\n\n  // Center control is important\n  if (board[4] === aiPlayer) {\n    score += 15;\n  } else if (board[4] === humanPlayer) {\n    score -= 15;\n  }\n\n  // Corner control\n  const corners = [0, 2, 6, 8];\n  for (const corner of corners) {\n    if (board[corner] === aiPlayer) {\n      score += 5;\n    } else if (board[corner] === humanPlayer) {\n      score -= 5;\n    }\n  }\n\n  return score;\n}\n\n/**\n * Evaluates the impact of removing a piece from the board\n */\nfunction evaluateImpactOfRemoval(\n  originalBoard: Board,\n  boardAfterRemoval: Board,\n  playerLosing: string,\n  playerGaining: string\n): number {\n  const originalControl = evaluateControlScore(originalBoard, playerGaining, playerLosing);\n  const newControl = evaluateControlScore(boardAfterRemoval, playerGaining, playerLosing);\n\n  // Return the difference - how much the control has changed\n  return newControl - originalControl;\n}","/**\n * Bayesian Opponent Modeling for Tic Tac Toe\n * \n * This module implements a probabilistic model of the opponent's behavior\n * using Bayesian inference to predict their next moves based on observed patterns.\n */\nimport type { Board, MoveResult } from './gameTypes';\n\n// Interface for tracking conditional probabilities P(move | board state)\ninterface ConditionalProbability {\n  boardState: string;     // Serialized board state\n  moveProbabilities: Map<number, number>; // Move index -> probability\n  totalObservations: number; // Total number of observations for this state\n}\n\n// Constants for the Bayesian model\nconst LEARNING_RATE = 0.2;   // Rate at which new observations update the model\nconst MIN_OBSERVATIONS = 2;  // Minimum observations before making predictions\n\n// Global state for the Bayesian model\nconst conditionalProbabilities = new Map<string, ConditionalProbability>();\n\n// Prior probability distribution for moves (based on common strategic preferences)\nconst priorDistribution = new Map<number, number>([\n  [0, 0.15], // Top-left corner\n  [1, 0.05], // Top-middle\n  [2, 0.15], // Top-right corner\n  [3, 0.05], // Middle-left\n  [4, 0.4],  // Center (strong prior)\n  [5, 0.05], // Middle-right\n  [6, 0.15], // Bottom-left corner\n  [7, 0.05], // Bottom-middle\n  [8, 0.15]  // Bottom-right corner\n]);\n\n/**\n * Helper function to serialize a board to string\n */\nfunction serializeBoard(board: Board): string {\n  return board.map(cell => cell === null ? '-' : cell).join('');\n}\n\n/**\n * Normalizes a board state by accounting for symmetries\n * to better generalize learned patterns\n */\nfunction getNormalizedBoardState(board: Board): string {\n  // Create all possible rotations and reflections\n  const orientations: string[] = [];\n  \n  // Original\n  orientations.push(board.map(c => c === null ? '-' : c).join(''));\n  \n  // 90° rotation\n  const rot90 = [\n    board[6], board[3], board[0],\n    board[7], board[4], board[1],\n    board[8], board[5], board[2]\n  ];\n  orientations.push(rot90.map(c => c === null ? '-' : c).join(''));\n  \n  // 180° rotation\n  const rot180 = [\n    board[8], board[7], board[6],\n    board[5], board[4], board[3],\n    board[2], board[1], board[0]\n  ];\n  orientations.push(rot180.map(c => c === null ? '-' : c).join(''));\n  \n  // 270° rotation\n  const rot270 = [\n    board[2], board[5], board[8],\n    board[1], board[4], board[7],\n    board[0], board[3], board[6]\n  ];\n  orientations.push(rot270.map(c => c === null ? '-' : c).join(''));\n  \n  // Horizontal flip\n  const flipH = [\n    board[2], board[1], board[0],\n    board[5], board[4], board[3],\n    board[8], board[7], board[6]\n  ];\n  orientations.push(flipH.map(c => c === null ? '-' : c).join(''));\n  \n  // Vertical flip\n  const flipV = [\n    board[6], board[7], board[8],\n    board[3], board[4], board[5],\n    board[0], board[1], board[2]\n  ];\n  orientations.push(flipV.map(c => c === null ? '-' : c).join(''));\n  \n  // Diagonal flip (top-left to bottom-right)\n  const flipD1 = [\n    board[0], board[3], board[6],\n    board[1], board[4], board[7],\n    board[2], board[5], board[8]\n  ];\n  orientations.push(flipD1.map(c => c === null ? '-' : c).join(''));\n  \n  // Diagonal flip (top-right to bottom-left)\n  const flipD2 = [\n    board[8], board[5], board[2],\n    board[7], board[4], board[1],\n    board[6], board[3], board[0]\n  ];\n  orientations.push(flipD2.map(c => c === null ? '-' : c).join(''));\n  \n  // Return the lexicographically smallest representation\n  return orientations.sort()[0];\n}\n\n/**\n * Maps a move from one board orientation to another\n */\nfunction mapMoveToOrientation(\n  move: number, \n  fromOrientation: string, \n  toOrientation: string\n): number {\n  // If orientations are the same, no mapping needed\n  if (fromOrientation === toOrientation) return move;\n  \n  // Define possible transformations and their move mappings\n  const transformations = [\n    [0, 1, 2, 3, 4, 5, 6, 7, 8], // Identity\n    [6, 3, 0, 7, 4, 1, 8, 5, 2], // 90° rotation\n    [8, 7, 6, 5, 4, 3, 2, 1, 0], // 180° rotation\n    [2, 5, 8, 1, 4, 7, 0, 3, 6], // 270° rotation\n    [2, 1, 0, 5, 4, 3, 8, 7, 6], // Horizontal flip\n    [6, 7, 8, 3, 4, 5, 0, 1, 2], // Vertical flip\n    [0, 3, 6, 1, 4, 7, 2, 5, 8], // Diagonal flip (top-left to bottom-right)\n    [8, 5, 2, 7, 4, 1, 6, 3, 0]  // Diagonal flip (top-right to bottom-left)\n  ];\n  \n  // Find transformation from fromOrientation to canonical form\n  \n  // Find which transformation produces the target orientation\n  for (const transform of transformations) {\n    // Apply transformation to from orientation\n    const transformedFrom = transform.map(i => fromOrientation[i]).join('');\n    if (transformedFrom === toOrientation) {\n      // Found the right transformation\n      return transform[move];\n    }\n    \n    // Apply inverse transformation to target orientation\n    const inverseTransform = transform.map((_, idx) => \n      transform.findIndex(v => v === idx));\n    const transformedTo = inverseTransform.map(i => toOrientation[i]).join('');\n    if (transformedTo === fromOrientation) {\n      // Found the inverse transformation\n      return inverseTransform[move];\n    }\n  }\n  \n  // If no transformation is found (should never happen)\n  console.error(\"Could not map move between orientations\");\n  return move;\n}\n\n/**\n * Observes a player's move and updates the Bayesian model\n */\nexport function observeMove(board: Board, moveIndex: number): void {\n  // Get the board state before the move\n  const boardCopy = [...board];\n  boardCopy[moveIndex] = null;\n  \n  // Get a normalized representation of the board state\n  const normalizedState = getNormalizedBoardState(boardCopy);\n  \n  // Map the move to the normalized orientation\n  const normalizedMove = mapMoveToOrientation(\n    moveIndex, \n    serializeBoard(boardCopy),\n    normalizedState\n  );\n  \n  // Get or create the conditional probability for this state\n  let conditionalProb = conditionalProbabilities.get(normalizedState);\n  if (!conditionalProb) {\n    conditionalProb = {\n      boardState: normalizedState,\n      moveProbabilities: new Map<number, number>(),\n      totalObservations: 0\n    };\n    \n    // Initialize with prior distribution\n    for (let i = 0; i < 9; i++) {\n      // Only set priors for valid moves in this state\n      if (normalizedState[i] === '-') {\n        conditionalProb.moveProbabilities.set(i, priorDistribution.get(i) || 0.1);\n      }\n    }\n    \n    conditionalProbabilities.set(normalizedState, conditionalProb);\n  }\n  \n  // Update the probability distribution with the observed move\n  const currentProb = conditionalProb.moveProbabilities.get(normalizedMove) || 0;\n  const newProb = currentProb * (1 - LEARNING_RATE) + LEARNING_RATE;\n  \n  // Update the probability of the observed move\n  conditionalProb.moveProbabilities.set(normalizedMove, newProb);\n  \n  // Normalize probabilities to sum to 1\n  let sum = 0;\n  conditionalProb.moveProbabilities.forEach(prob => sum += prob);\n  \n  conditionalProb.moveProbabilities.forEach((prob, move) => {\n    conditionalProb!.moveProbabilities.set(move, prob / sum);\n  });\n  \n  // Increment observation count\n  conditionalProb.totalObservations += 1;\n}\n\n/**\n * Predicts the opponent's next move using the Bayesian model\n */\nexport function predictOpponentMove(board: Board): { move: number, confidence: number } | null {\n  const normalizedState = getNormalizedBoardState(board);\n  \n  // Get the conditional probability for this state\n  const conditionalProb = conditionalProbabilities.get(normalizedState);\n  \n  // If we don't have enough observations for this state, return null\n  if (!conditionalProb || conditionalProb.totalObservations < MIN_OBSERVATIONS) {\n    return null;\n  }\n  \n  // Find the move with highest probability\n  let bestMove = -1;\n  let highestProb = 0;\n  \n  conditionalProb.moveProbabilities.forEach((probability, move) => {\n    // Check if the move is valid in the current board\n    const originalMove = mapMoveToOrientation(\n      move, \n      normalizedState,\n      board.map(c => c === null ? '-' : c).join('')\n    );\n    \n    if (board[originalMove] === null && probability > highestProb) {\n      highestProb = probability;\n      bestMove = originalMove;\n    }\n  });\n  \n  if (bestMove === -1) {\n    return null;\n  }\n  \n  return { \n    move: bestMove, \n    confidence: highestProb\n  };\n}\n\n/**\n * Suggests a counter-move based on the predicted opponent move\n */\nexport function getBayesianCounterMove(board: Board): MoveResult | null {\n  const prediction = predictOpponentMove(board);\n  \n  if (!prediction) {\n    return null;\n  }\n  \n  // If the confidence is high enough, use the predicted move\n  if (prediction.confidence > 0.6) {\n    return prediction.move;\n  }\n  \n  // If confidence is moderate, consider the predicted move but allow\n  // for other strategies to take precedence\n  return prediction.confidence > 0.3 ? prediction.move : null;\n}\n\n/**\n * Resets the Bayesian model\n */\nexport function resetBayesianModel(): void {\n  conditionalProbabilities.clear();\n}\n\n/**\n * Load Bayesian state from saved data\n */\nexport function loadBayesianState(data: BayesianStats): boolean {\n  try {\n    if (!data || !data.patternDetails || !Array.isArray(data.patternDetails)) {\n      return false;\n    }\n    \n    // Reset first to ensure clean state\n    resetBayesianModel();\n    \n    // Reconstruct the conditional probabilities from saved data\n    data.patternDetails.forEach(pattern => {\n      if (!pattern.boardState || !pattern.probabilities || !Array.isArray(pattern.probabilities)) {\n        return;\n      }\n      \n      const moveProbabilities = new Map<number, number>();\n      pattern.probabilities.forEach(moveProb => {\n        if (moveProb.move !== undefined && moveProb.probability !== undefined) {\n          moveProbabilities.set(moveProb.move, moveProb.probability);\n        }\n      });\n      \n      // Create and store the conditional probability\n      const conditionalProb: ConditionalProbability = {\n        boardState: pattern.boardState,\n        moveProbabilities,\n        totalObservations: Math.max(1, pattern.observations || 1)\n      };\n      \n      conditionalProbabilities.set(pattern.boardState, conditionalProb);\n    });\n    \n    return true;\n  } catch (error) {\n    console.error('Error loading Bayesian state:', error);\n    return false;\n  }\n}\n\n/**\n * Gets statistics about the Bayesian model\n */\nexport interface BayesianStats {\n  totalPatterns: number;\n  patternDetails: Array<{\n    boardState: string;\n    observations: number;\n    probabilities: Array<{\n      move: number;\n      probability: number;\n    }>;\n  }>;\n}\n\nexport function getBayesianStats(): BayesianStats {\n  return {\n    totalPatterns: conditionalProbabilities.size,\n    patternDetails: Array.from(conditionalProbabilities.entries())\n      .map(([state, data]) => ({\n        boardState: state,\n        observations: data.totalObservations,\n        probabilities: Array.from(data.moveProbabilities.entries())\n          .map(([move, prob]) => ({ move, probability: prob }))\n          .sort((a, b) => b.probability - a.probability)\n      }))\n      .sort((a, b) => b.observations - a.observations)\n  };\n}","/**\n * Monte Carlo Tree Search (MCTS) algorithm for Tic Tac Toe\n * This provides a much more advanced AI that can learn and adapt through experience\n */\nimport { hasWinningMove } from './boardEvaluator';\nimport type { Board, MoveResult } from './gameTypes';\n\n// Node in the Monte Carlo search tree\ninterface MCTSNode {\n  state: Board;        // Board state at this node\n  parent: MCTSNode | null;  // Parent node\n  children: MCTSNode[];     // Child nodes\n  moves: number[];          // Available moves from this state\n  playerSymbol: string;     // Player to move at this state\n  visits: number;           // Number of times this node has been visited\n  wins: number;             // Number of wins through this node\n  untriedMoves: number[];   // Moves not yet explored from this state\n}\n\n// Constants for MCTS\nconst EXPLORATION_PARAMETER = 1.414; // UCB1 exploration parameter (sqrt(2))\nconst DEFAULT_ITERATIONS = 1000;     // Default number of iterations\nconst MAX_TIME_MS = 500;            // Maximum time for search in milliseconds\n\n/**\n * Creates a new node in the search tree\n */\nfunction createNode(\n  state: Board, \n  parent: MCTSNode | null, \n  moves: number[], \n  playerSymbol: string\n): MCTSNode {\n  return {\n    state: [...state],\n    parent,\n    children: [],\n    moves,\n    playerSymbol,\n    visits: 0,\n    wins: 0,\n    untriedMoves: [...moves]\n  };\n}\n\n/**\n * Selects a child node using UCB1 formula\n */\nfunction selectChild(node: MCTSNode): MCTSNode {\n  let bestScore = -Infinity;\n  let bestChild: MCTSNode | null = null;\n  \n  for (const child of node.children) {\n    // UCB1 formula: wins/visits + C * sqrt(ln(parent visits) / visits)\n    const exploitation = child.wins / child.visits;\n    const exploration = EXPLORATION_PARAMETER * Math.sqrt(Math.log(node.visits) / child.visits);\n    const score = exploitation + exploration;\n    \n    if (score > bestScore) {\n      bestScore = score;\n      bestChild = child;\n    }\n  }\n  \n  return bestChild!; // We know there's at least one child\n}\n\n/**\n * Expands the tree by adding a child node for an unexplored move\n */\nfunction expand(node: MCTSNode): MCTSNode {\n  // Get a random untried move\n  const moveIndex = Math.floor(Math.random() * node.untriedMoves.length);\n  const move = node.untriedMoves[moveIndex];\n  \n  // Remove this move from untried moves\n  node.untriedMoves.splice(moveIndex, 1);\n  \n  // Create new state after making this move\n  const nextState = [...node.state];\n  nextState[move] = node.playerSymbol;\n  \n  // Calculate available moves for the next state\n  const nextMoves = getAvailableMoves(nextState);\n  \n  // Switch to the other player\n  const nextPlayer = node.playerSymbol === 'X' ? 'O' : 'X';\n  \n  // Create child node\n  const childNode = createNode(nextState, node, nextMoves, nextPlayer);\n  \n  // Add child to parent's children\n  node.children.push(childNode);\n  \n  return childNode;\n}\n\n/**\n * Simulates a random play-out from the given state\n * Returns the result from the perspective of the player who made the last move\n */\nfunction simulate(node: MCTSNode): number {\n  // Make a copy of the state to simulate\n  const state = [...node.state];\n  let currentPlayer = node.playerSymbol;\n  \n  // Get available moves\n  let availableMoves = getAvailableMoves(state);\n  \n  // Continue until terminal state\n  while (availableMoves.length > 0) {\n    // Check for a winner\n    const winner = checkWinner(state);\n    if (winner !== null) {\n      return winner === node.playerSymbol ? 1 : 0; // Win or loss\n    }\n    \n    // Random move\n    const moveIndex = Math.floor(Math.random() * availableMoves.length);\n    const move = availableMoves[moveIndex];\n    \n    // Make move\n    state[move] = currentPlayer;\n    \n    // Switch player\n    currentPlayer = currentPlayer === 'X' ? 'O' : 'X';\n    \n    // Update available moves\n    availableMoves = getAvailableMoves(state);\n  }\n  \n  // Check if there's a winner in the final state\n  const winner = checkWinner(state);\n  if (winner === null) {\n    return 0.5; // Draw\n  }\n  \n  return winner === node.playerSymbol ? 1 : 0; // Win or loss\n}\n\n/**\n * Backpropagates the result through the tree\n */\nfunction backpropagate(node: MCTSNode, result: number): void {\n  let current: MCTSNode | null = node;\n  \n  while (current !== null) {\n    current.visits += 1;\n    \n    // The result needs to be inverted as we move up the tree\n    // because the winner alternates with each level\n    if (current.playerSymbol === node.playerSymbol) {\n      current.wins += result;\n    } else {\n      current.wins += (1 - result); // Invert result for opponent\n    }\n    \n    current = current.parent;\n  }\n}\n\n/**\n * Gets all available moves in the given state\n */\nfunction getAvailableMoves(board: Board): number[] {\n  return board\n    .map((cell, index) => cell === null ? index : -1)\n    .filter(index => index !== -1);\n}\n\n/**\n * Serialize a board to string representation\n */\nexport function serializeBoard(board: Board): string {\n  return board.map(cell => cell === null ? '-' : cell).join('');\n}\n\n/**\n * Checks if there is a winner in the given state\n */\nfunction checkWinner(board: Board): string | null {\n  const lines = [\n    [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows\n    [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns\n    [0, 4, 8], [2, 4, 6]             // Diagonals\n  ];\n  \n  for (const [a, b, c] of lines) {\n    if (board[a] && board[a] === board[b] && board[a] === board[c]) {\n      return board[a];\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Runs the Monte Carlo Tree Search algorithm\n * @param board Current board state\n * @param player Current player ('X' or 'O')\n * @param iterations Number of iterations to run\n * @returns The best move found\n */\nexport function findBestMoveMCTS(\n  board: Board, \n  player: string, \n  iterations: number = DEFAULT_ITERATIONS\n): MoveResult {\n  // First, check for immediate winning moves and blocking moves\n  const winningMove = hasWinningMove(board, player);\n  if (winningMove !== null) {\n    return winningMove;\n  }\n  \n  const opponent = player === 'X' ? 'O' : 'X';\n  const blockingMove = hasWinningMove(board, opponent);\n  if (blockingMove !== null) {\n    return blockingMove;\n  }\n  \n  // Get available moves\n  const availableMoves = getAvailableMoves(board);\n  \n  // If there's only one move, return it immediately\n  if (availableMoves.length === 1) {\n    return availableMoves[0];\n  }\n  \n  // If no moves available, return -1\n  if (availableMoves.length === 0) {\n    return -1;\n  }\n  \n  // Create root node\n  const rootNode = createNode(board, null, availableMoves, player);\n  \n  // Record start time to enforce time limit\n  const startTime = Date.now();\n  let iterationsCompleted = 0;\n  \n  // Main MCTS loop\n  while (iterationsCompleted < iterations && (Date.now() - startTime) < MAX_TIME_MS) {\n    // Selection: select best child until we reach a node with untried moves or a terminal node\n    let node = rootNode;\n    while (node.untriedMoves.length === 0 && node.children.length > 0) {\n      node = selectChild(node);\n    }\n    \n    // Expansion: if node has untried moves, expand it\n    if (node.untriedMoves.length > 0) {\n      node = expand(node);\n    }\n    \n    // Simulation: run a random simulation from the new node\n    const result = simulate(node);\n    \n    // Backpropagation: update statistics back up the tree\n    backpropagate(node, result);\n    \n    iterationsCompleted++;\n  }\n  \n  // Find the move with the most visits\n  let bestMove = -1;\n  let mostVisits = -1;\n  \n  for (const child of rootNode.children) {\n    if (child.visits > mostVisits) {\n      mostVisits = child.visits;\n      // Find which move led to this child\n      for (let i = 0; i < board.length; i++) {\n        if (board[i] !== child.state[i]) {\n          bestMove = i;\n          break;\n        }\n      }\n    }\n  }\n  \n  return bestMove;\n}\n\n/**\n * Helper method to get stats about the MCTS search\n * Useful for debugging and tuning\n */\nexport function getMCTSStats(\n  board: Board, \n  player: string, \n  iterations: number = DEFAULT_ITERATIONS\n): {\n  iterationsCompleted: number;\n  timeSpent: number;\n  totalSimulations: number;\n  moveStats: Array<{\n    move: number;\n    visits: number;\n    wins: number;\n    winRate: number;\n  }>;\n} {\n  const rootNode = createNode(board, null, getAvailableMoves(board), player);\n  \n  const startTime = Date.now();\n  let iterationsCompleted = 0;\n  \n  // Main MCTS loop\n  while (iterationsCompleted < iterations && (Date.now() - startTime) < MAX_TIME_MS) {\n    let node = rootNode;\n    while (node.untriedMoves.length === 0 && node.children.length > 0) {\n      node = selectChild(node);\n    }\n    \n    if (node.untriedMoves.length > 0) {\n      node = expand(node);\n    }\n    \n    const result = simulate(node);\n    backpropagate(node, result);\n    \n    iterationsCompleted++;\n  }\n  \n  // Collect stats for each potential move\n  const moveStats = rootNode.children.map(child => {\n    // Find which move led to this child\n    let moveIndex = -1;\n    for (let i = 0; i < board.length; i++) {\n      if (board[i] !== child.state[i]) {\n        moveIndex = i;\n        break;\n      }\n    }\n    \n    return {\n      move: moveIndex,\n      visits: child.visits,\n      wins: child.wins,\n      winRate: child.wins / child.visits\n    };\n  });\n  \n  return {\n    iterationsCompleted,\n    timeSpent: Date.now() - startTime,\n    totalSimulations: rootNode.visits,\n    moveStats: moveStats.sort((a, b) => b.visits - a.visits)\n  };\n}","/**\n * Multi-Armed Bandit Strategy Selector for Tic Tac Toe AI\n * \n * This module implements a Thompson sampling approach to select between\n * different AI strategies based on their past performance against the player.\n * It dynamically adapts to find the most effective approach for each opponent.\n */\nimport type { Board, MoveResult, GameStyle } from './gameTypes';\nimport { findBestMove } from './aiOpponent';\nimport { findBestMoveMCTS } from './monteCarlo';\nimport { getBayesianCounterMove } from './bayesianModel';\nimport { hasWinningMove, hasForkMove } from './boardEvaluator';\n\n// Define strategy types\nexport type StrategyName = \n  | 'minimax'      // Traditional minimax algorithm\n  | 'mcts'         // Monte Carlo Tree Search\n  | 'bayesian'     // Bayesian opponent modeling\n  | 'aggressive'   // Focus on creating winning opportunities\n  | 'defensive'    // Focus on blocking opponent moves\n  | 'corners'      // Prioritize taking corners\n  | 'center'       // Prioritize taking center then corners\n  | 'random';      // Random valid moves (for exploration)\n\n// Interface for strategy statistics\ninterface StrategyStats {\n  name: StrategyName;\n  wins: number;        // Number of wins\n  losses: number;      // Number of losses\n  draws: number;       // Number of draws\n  total: number;       // Total uses\n  alpha: number;       // Beta distribution parameter for Thompson sampling\n  beta: number;        // Beta distribution parameter for Thompson sampling\n}\n\n// Initialize strategy statistics\nconst strategies: Map<StrategyName, StrategyStats> = new Map([\n  ['minimax', { name: 'minimax', wins: 1, losses: 1, draws: 1, total: 3, alpha: 1, beta: 1 }],\n  ['mcts', { name: 'mcts', wins: 1, losses: 1, draws: 1, total: 3, alpha: 1, beta: 1 }],\n  ['bayesian', { name: 'bayesian', wins: 1, losses: 1, draws: 1, total: 3, alpha: 1, beta: 1 }],\n  ['aggressive', { name: 'aggressive', wins: 1, losses: 1, draws: 1, total: 3, alpha: 1, beta: 1 }],\n  ['defensive', { name: 'defensive', wins: 1, losses: 1, draws: 1, total: 3, alpha: 1, beta: 1 }],\n  ['corners', { name: 'corners', wins: 1, losses: 1, draws: 1, total: 3, alpha: 1, beta: 1 }],\n  ['center', { name: 'center', wins: 1, losses: 1, draws: 1, total: 3, alpha: 1, beta: 1 }],\n  ['random', { name: 'random', wins: 1, losses: 1, draws: 1, total: 3, alpha: 1, beta: 1 }]\n]);\n\n// Track the current active strategy\nlet currentStrategy: StrategyName | null = null;\n\n/**\n * Sample from a beta distribution\n * Used for Thompson sampling\n */\nfunction sampleBeta(alpha: number, beta: number): number {\n  // This is an approximation of beta distribution sampling\n  // For more accurate sampling, a proper stats library would be better\n  const u = Math.random();\n  const v = Math.random();\n  const x = Math.pow(u, 1/alpha);\n  const y = Math.pow(v, 1/beta);\n  return x / (x + y);\n}\n\n/**\n * Select a strategy using Thompson sampling\n */\nexport function selectStrategy(): StrategyName {\n  // Sample from each strategy's beta distribution\n  let bestStrategy: StrategyName = 'minimax';\n  let highestSample = -Infinity;\n  \n  strategies.forEach((stats, name) => {\n    const sample = sampleBeta(stats.alpha, stats.beta);\n    if (sample > highestSample) {\n      highestSample = sample;\n      bestStrategy = name;\n    }\n  });\n  \n  currentStrategy = bestStrategy;\n  return bestStrategy;\n}\n\n/**\n * Update strategy performance based on game outcome\n */\nexport function updateStrategyPerformance(\n  strategy: StrategyName,\n  result: 'win' | 'loss' | 'draw'\n): void {\n  const stats = strategies.get(strategy);\n  if (!stats) return;\n  \n  // Update raw counts\n  if (result === 'win') {\n    stats.wins += 1;\n    stats.alpha += 1;\n  } else if (result === 'loss') {\n    stats.losses += 1;\n    stats.beta += 1;\n  } else {\n    stats.draws += 1;\n    stats.alpha += 0.5;\n    stats.beta += 0.5;\n  }\n  \n  stats.total += 1;\n  \n  // Update the strategies map\n  strategies.set(strategy, stats);\n}\n\n/**\n * Record the game outcome for the current strategy\n */\nexport function recordGameOutcome(winner: string | null, aiPlayer: string): void {\n  if (!currentStrategy) return;\n  \n  let result: 'win' | 'loss' | 'draw';\n  \n  if (winner === null) {\n    result = 'draw';\n  } else if (winner === aiPlayer) {\n    result = 'win';\n  } else {\n    result = 'loss';\n  }\n  \n  updateStrategyPerformance(currentStrategy, result);\n}\n\n/**\n * Get available moves on the board\n */\nfunction getAvailableMoves(board: Board): number[] {\n  return board\n    .map((cell, index) => cell === null ? index : -1)\n    .filter(index => index !== -1);\n}\n\n/**\n * Implements the aggressive strategy\n * Focuses on creating winning opportunities\n */\nfunction aggressiveStrategy(\n  board: Board, \n  aiPlayer: string\n): MoveResult {\n  const opponent = aiPlayer === 'X' ? 'O' : 'X';\n  \n  // First check for a winning move\n  const winningMove = hasWinningMove(board, aiPlayer);\n  if (winningMove !== null) {\n    return winningMove;\n  }\n  \n  // Then check for opponent's winning move to block\n  const blockingMove = hasWinningMove(board, opponent);\n  if (blockingMove !== null) {\n    return blockingMove;\n  }\n  \n  // Look for fork opportunities\n  const forkMove = hasForkMove(board, aiPlayer);\n  if (forkMove !== null) {\n    return forkMove;\n  }\n  \n  // If center is available, take it\n  if (board[4] === null) {\n    return 4;\n  }\n  \n  // Prefer corners that create more opportunities\n  const corners = [0, 2, 6, 8].filter(i => board[i] === null);\n  if (corners.length > 0) {\n    // Check which corner creates the most potential winning lines\n    let bestCorner = corners[0];\n    let bestScore = -Infinity;\n    \n    for (const corner of corners) {\n      // Try this corner\n      board[corner] = aiPlayer;\n      \n      // Count potential winning lines\n      let score = 0;\n      const lines = [\n        [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows\n        [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns\n        [0, 4, 8], [2, 4, 6]             // Diagonals\n      ];\n      \n      for (const [a, b, c] of lines) {\n        if ((board[a] === aiPlayer || board[a] === null) &&\n            (board[b] === aiPlayer || board[b] === null) &&\n            (board[c] === aiPlayer || board[c] === null)) {\n          score += 1;\n          \n          // If there are already two of our pieces, higher score\n          if ((board[a] === aiPlayer && board[b] === aiPlayer) ||\n              (board[b] === aiPlayer && board[c] === aiPlayer) ||\n              (board[a] === aiPlayer && board[c] === aiPlayer)) {\n            score += 3;\n          }\n        }\n      }\n      \n      // Undo move\n      board[corner] = null;\n      \n      if (score > bestScore) {\n        bestScore = score;\n        bestCorner = corner;\n      }\n    }\n    \n    return bestCorner;\n  }\n  \n  // Take any available side\n  const sides = [1, 3, 5, 7].filter(i => board[i] === null);\n  if (sides.length > 0) {\n    return sides[Math.floor(Math.random() * sides.length)];\n  }\n  \n  // Take any available move\n  const availableMoves = getAvailableMoves(board);\n  return availableMoves[Math.floor(Math.random() * availableMoves.length)];\n}\n\n/**\n * Implements the defensive strategy\n * Focuses on blocking opponent moves and safe play\n */\nfunction defensiveStrategy(\n  board: Board,\n  aiPlayer: string\n): MoveResult {\n  const opponent = aiPlayer === 'X' ? 'O' : 'X';\n  \n  // First check for a winning move\n  const winningMove = hasWinningMove(board, aiPlayer);\n  if (winningMove !== null) {\n    return winningMove;\n  }\n  \n  // Then check for opponent's winning move to block\n  const blockingMove = hasWinningMove(board, opponent);\n  if (blockingMove !== null) {\n    return blockingMove;\n  }\n  \n  // Block potential fork opportunities for opponent\n  const opponentForkMove = hasForkMove(board, opponent);\n  if (opponentForkMove !== null) {\n    return opponentForkMove;\n  }\n  \n  // If center is available, take it\n  if (board[4] === null) {\n    return 4;\n  }\n  \n  // Check which move minimizes opponent's potential winning lines\n  const availableMoves = getAvailableMoves(board);\n  let bestMove = availableMoves[0];\n  let lowestOpponentScore = Infinity;\n  \n  for (const move of availableMoves) {\n    // Try this move\n    board[move] = aiPlayer;\n    \n    // Count opponent's potential winning lines\n    let opponentScore = 0;\n    const lines = [\n      [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows\n      [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns\n      [0, 4, 8], [2, 4, 6]             // Diagonals\n    ];\n    \n    for (const [a, b, c] of lines) {\n      if ((board[a] === opponent || board[a] === null) &&\n          (board[b] === opponent || board[b] === null) &&\n          (board[c] === opponent || board[c] === null) &&\n          !(board[a] === aiPlayer || board[b] === aiPlayer || board[c] === aiPlayer)) {\n        opponentScore += 1;\n        \n        // If there are already two of opponent's pieces, much higher score (threat)\n        if ((board[a] === opponent && board[b] === opponent) ||\n            (board[b] === opponent && board[c] === opponent) ||\n            (board[a] === opponent && board[c] === opponent)) {\n          opponentScore += 5;\n        }\n      }\n    }\n    \n    // Undo move\n    board[move] = null;\n    \n    if (opponentScore < lowestOpponentScore) {\n      lowestOpponentScore = opponentScore;\n      bestMove = move;\n    }\n  }\n  \n  return bestMove;\n}\n\n/**\n * Implements the corners strategy\n * Prioritizes taking corners in a specific pattern\n */\nfunction cornersStrategy(\n  board: Board,\n  aiPlayer: string\n): MoveResult {\n  const opponent = aiPlayer === 'X' ? 'O' : 'X';\n  \n  // First check for a winning move\n  const winningMove = hasWinningMove(board, aiPlayer);\n  if (winningMove !== null) {\n    return winningMove;\n  }\n  \n  // Then check for opponent's winning move to block\n  const blockingMove = hasWinningMove(board, opponent);\n  if (blockingMove !== null) {\n    return blockingMove;\n  }\n  \n  // Preferred corner order: Top-Left, Bottom-Right, Top-Right, Bottom-Left\n  const cornerPreference = [0, 8, 2, 6];\n  for (const corner of cornerPreference) {\n    if (board[corner] === null) {\n      return corner;\n    }\n  }\n  \n  // If no corners available, take center\n  if (board[4] === null) {\n    return 4;\n  }\n  \n  // If all corners and center taken, take any side\n  const sides = [1, 3, 5, 7].filter(i => board[i] === null);\n  if (sides.length > 0) {\n    return sides[0];\n  }\n  \n  // Take any available move\n  const availableMoves = getAvailableMoves(board);\n  return availableMoves[0];\n}\n\n/**\n * Implements the center strategy\n * Prioritizes taking center, then corners\n */\nfunction centerStrategy(\n  board: Board,\n  aiPlayer: string\n): MoveResult {\n  const opponent = aiPlayer === 'X' ? 'O' : 'X';\n  \n  // First check for a winning move\n  const winningMove = hasWinningMove(board, aiPlayer);\n  if (winningMove !== null) {\n    return winningMove;\n  }\n  \n  // Then check for opponent's winning move to block\n  const blockingMove = hasWinningMove(board, opponent);\n  if (blockingMove !== null) {\n    return blockingMove;\n  }\n  \n  // Take center if available\n  if (board[4] === null) {\n    return 4;\n  }\n  \n  // Take opposite corner of opponent's piece if possible\n  const cornerPairs = [[0, 8], [2, 6]];\n  for (const [c1, c2] of cornerPairs) {\n    if (board[c1] === opponent && board[c2] === null) {\n      return c2;\n    }\n    if (board[c2] === opponent && board[c1] === null) {\n      return c1;\n    }\n  }\n  \n  // Take any corner\n  const corners = [0, 2, 6, 8].filter(i => board[i] === null);\n  if (corners.length > 0) {\n    return corners[Math.floor(Math.random() * corners.length)];\n  }\n  \n  // Take any side\n  const sides = [1, 3, 5, 7].filter(i => board[i] === null);\n  if (sides.length > 0) {\n    return sides[Math.floor(Math.random() * sides.length)];\n  }\n  \n  // Take any available move\n  const availableMoves = getAvailableMoves(board);\n  return availableMoves[Math.floor(Math.random() * availableMoves.length)];\n}\n\n/**\n * Random move strategy (for exploration)\n */\nfunction randomStrategy(\n  board: Board\n): MoveResult {\n  const availableMoves = getAvailableMoves(board);\n  \n  if (availableMoves.length === 0) {\n    return -1;\n  }\n  \n  return availableMoves[Math.floor(Math.random() * availableMoves.length)];\n}\n\n/**\n * Get a move using the specified strategy\n */\nexport function getStrategyMove(\n  strategy: StrategyName,\n  board: Board,\n  aiPlayer: string,\n  gameStyle: GameStyle = 'classic',\n  xMoves: number[] = [],\n  oMoves: number[] = []\n): MoveResult {\n  // Immediate win check for all strategies\n  const winningMove = hasWinningMove(board, aiPlayer);\n  if (winningMove !== null) {\n    return winningMove;\n  }\n  \n  // Block check for all strategies\n  const opponent = aiPlayer === 'X' ? 'O' : 'X';\n  const blockingMove = hasWinningMove(board, opponent);\n  if (blockingMove !== null) {\n    return blockingMove;\n  }\n  \n  switch (strategy) {\n    case 'minimax':\n      return findBestMove(board, aiPlayer, gameStyle, xMoves, oMoves, 'hard');\n    \n    case 'mcts':\n      return findBestMoveMCTS(board, aiPlayer);\n    \n    case 'bayesian': {\n      const bayesianMove = getBayesianCounterMove(board);\n      if (bayesianMove !== null) {\n        return bayesianMove;\n      }\n      // Fall back to MCTS if bayesian doesn't have enough data\n      return findBestMoveMCTS(board, aiPlayer);\n    }\n    \n    case 'aggressive':\n      return aggressiveStrategy(board, aiPlayer);\n    \n    case 'defensive':\n      return defensiveStrategy(board, aiPlayer);\n    \n    case 'corners':\n      return cornersStrategy(board, aiPlayer);\n    \n    case 'center':\n      return centerStrategy(board, aiPlayer);\n    \n    case 'random':\n      return randomStrategy(board);\n    \n    default:\n      return findBestMove(board, aiPlayer, gameStyle, xMoves, oMoves, 'hard');\n  }\n}\n\n/**\n * Make a move using the multi-armed bandit strategy selector\n * This is the main function to use from outside this module\n */\nexport function getAdaptiveStrategyMove(\n  board: Board,\n  aiPlayer: string,\n  gameStyle: GameStyle = 'classic',\n  xMoves: number[] = [],\n  oMoves: number[] = []\n): MoveResult {\n  // Select strategy using the bandit algorithm\n  const strategy = selectStrategy();\n  \n  // Use the selected strategy to make a move\n  return getStrategyMove(strategy, board, aiPlayer, gameStyle, xMoves, oMoves);\n}\n\n/**\n * Get statistics about the bandit strategy selector\n */\nexport interface BanditStats {\n  strategies: Array<{\n    name: string;\n    wins: number;\n    losses: number;\n    draws: number;\n    total: number;\n    winRate: number;\n    alpha: number;\n    beta: number;\n    expectedValue: number;\n  }>;\n  currentStrategy: StrategyName | null;\n}\n\nexport function getBanditStats(): BanditStats {\n  return {\n    strategies: Array.from(strategies.entries()).map(([name, stats]) => ({\n      name,\n      wins: stats.wins,\n      losses: stats.losses,\n      draws: stats.draws,\n      total: stats.total,\n      winRate: stats.wins / stats.total,\n      alpha: stats.alpha,\n      beta: stats.beta,\n      expectedValue: stats.alpha / (stats.alpha + stats.beta)\n    })),\n    currentStrategy\n  };\n}\n\n/**\n * Reset the bandit strategy selector\n */\nexport function resetBandit(): void {\n  strategies.forEach((stats) => {\n    stats.wins = 1;\n    stats.losses = 1;\n    stats.draws = 1;\n    stats.total = 3;\n    stats.alpha = 1;\n    stats.beta = 1;\n  });\n  \n  currentStrategy = null;\n}\n\n/**\n * Load bandit state from saved data\n */\nexport function loadBanditState(data: BanditStats): boolean {\n  try {\n    if (!data || !data.strategies || !Array.isArray(data.strategies)) {\n      return false;\n    }\n    \n    // Reset first to ensure clean state\n    resetBandit();\n    \n    // Update strategies with saved data\n    data.strategies.forEach(savedStrategy => {\n      const strategy = strategies.get(savedStrategy.name as StrategyName);\n      if (strategy) {\n        // Use saved values, but ensure they're valid\n        strategy.wins = Math.max(1, savedStrategy.wins || 1);\n        strategy.losses = Math.max(1, savedStrategy.losses || 1);\n        strategy.draws = Math.max(0, savedStrategy.draws || 0);\n        strategy.total = Math.max(2, savedStrategy.total || 2);\n        strategy.alpha = Math.max(1, savedStrategy.alpha || 1);\n        strategy.beta = Math.max(1, savedStrategy.beta || 1);\n      }\n    });\n    \n    // Restore current strategy if valid\n    if (data.currentStrategy) {\n      currentStrategy = data.currentStrategy;\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error loading bandit state:', error);\n    return false;\n  }\n}","/**\n * Persistent Learning Database for Tic Tac Toe AI\n * \n * This module implements a persistent storage system for the AI's learning data,\n * allowing it to remember and improve across game sessions.\n */\nimport { getBanditStats, resetBandit } from './banditStrategies';\nimport { getBayesianStats, resetBayesianModel } from './bayesianModel';\n\n// Storage keys\nconst STORAGE_KEY_PREFIX = 'tictactoe_ai_';\nconst BANDIT_STORAGE_KEY = `${STORAGE_KEY_PREFIX}bandit`;\nconst BAYESIAN_STORAGE_KEY = `${STORAGE_KEY_PREFIX}bayesian`;\nconst TIMESTAMP_STORAGE_KEY = `${STORAGE_KEY_PREFIX}timestamp`;\nconst LEARNING_VERSION = '1.0.0'; // Version to handle data format changes\n\n// Interface for persistable state\ninterface PersistableState {\n  version: string;\n  timestamp: number;\n  banditData: unknown;\n  bayesianData: unknown;\n}\n\n/**\n * Save the current learning state to localStorage\n */\nexport function saveLearnedData(): boolean {\n  try {\n    // Get current data from the learning systems\n    const banditData = getBanditStats();\n    const bayesianData = getBayesianStats();\n    \n    // Create persistent state object\n    const stateToSave: PersistableState = {\n      version: LEARNING_VERSION,\n      timestamp: Date.now(),\n      banditData,\n      bayesianData\n    };\n    \n    // Save to localStorage\n    localStorage.setItem(\n      BANDIT_STORAGE_KEY, \n      JSON.stringify(stateToSave.banditData)\n    );\n    localStorage.setItem(\n      BAYESIAN_STORAGE_KEY, \n      JSON.stringify(stateToSave.bayesianData)\n    );\n    \n    // Save the timestamp separately\n    localStorage.setItem(\n      TIMESTAMP_STORAGE_KEY,\n      JSON.stringify({ timestamp: Date.now() })\n    );\n    \n    console.log('AI learning data saved successfully');\n    return true;\n  } catch (error) {\n    console.error('Error saving AI learning data:', error);\n    return false;\n  }\n}\n\n/**\n * Load learned data from localStorage\n */\nexport function loadLearnedData(): boolean {\n  try {\n    // Check if we have data in storage\n    const banditDataStr = localStorage.getItem(BANDIT_STORAGE_KEY);\n    const bayesianDataStr = localStorage.getItem(BAYESIAN_STORAGE_KEY);\n    \n    if (!banditDataStr || !bayesianDataStr) {\n      console.log('No previous learning data found');\n      return false;\n    }\n    \n    // Parse the data\n    try {\n      const parsedBanditData = JSON.parse(banditDataStr);\n      const parsedBayesianData = JSON.parse(bayesianDataStr);\n      \n      // Import functions dynamically to avoid circular dependencies\n      import('./banditStrategies').then(banditModule => {\n        if (typeof banditModule.loadBanditState === 'function') {\n          banditModule.loadBanditState(parsedBanditData);\n        }\n      });\n      \n      import('./bayesianModel').then(bayesianModule => {\n        if (typeof bayesianModule.loadBayesianState === 'function') {\n          bayesianModule.loadBayesianState(parsedBayesianData);\n        }\n      });\n      \n      console.log('AI learning data loaded successfully');\n      return true;\n    } catch (parseError) {\n      console.error('Error parsing stored AI data:', parseError);\n      // If parsing fails, remove the corrupted data\n      localStorage.removeItem(BANDIT_STORAGE_KEY);\n      localStorage.removeItem(BAYESIAN_STORAGE_KEY);\n      return false;\n    }\n  } catch (error) {\n    console.error('Error loading AI learning data:', error);\n    return false;\n  }\n}\n\n/**\n * Reset all learned data\n */\nexport function resetLearnedData(): void {\n  // Clear localStorage\n  localStorage.removeItem(BANDIT_STORAGE_KEY);\n  localStorage.removeItem(BAYESIAN_STORAGE_KEY);\n  localStorage.removeItem(TIMESTAMP_STORAGE_KEY);\n  \n  // Reset the learning systems\n  resetBandit();\n  resetBayesianModel();\n  \n  console.log('AI learning data reset successfully');\n}\n\n/**\n * Get statistics about the learning data\n */\nexport interface LearningStats {\n  bandit: unknown;\n  bayesian: unknown;\n  persistence: {\n    hasSavedBanditData: boolean;\n    hasSavedBayesianData: boolean;\n    lastSavedTimestamp: number | null;\n    error?: string;\n  };\n}\n\nexport function getLearningStats(): LearningStats {\n  const banditStats = getBanditStats();\n  const bayesianStats = getBayesianStats();\n  \n  // Check if we have data in storage\n  let persistenceInfo;\n  try {\n    const banditDataStr = localStorage.getItem(BANDIT_STORAGE_KEY);\n    const bayesianDataStr = localStorage.getItem(BAYESIAN_STORAGE_KEY);\n    const timestampData = localStorage.getItem(TIMESTAMP_STORAGE_KEY);\n    \n    persistenceInfo = {\n      hasSavedBanditData: !!banditDataStr,\n      hasSavedBayesianData: !!bayesianDataStr,\n      lastSavedTimestamp: timestampData \n        ? JSON.parse(timestampData).timestamp \n        : null\n    };\n  } catch (error) {\n    persistenceInfo = {\n      hasSavedBanditData: false,\n      hasSavedBayesianData: false,\n      lastSavedTimestamp: null,\n      error: error instanceof Error ? error.message : String(error)\n    };\n  }\n  \n  return {\n    bandit: banditStats,\n    bayesian: bayesianStats,\n    persistence: persistenceInfo\n  };\n}\n\n/**\n * Auto-save learning data periodically or when the window is about to unload\n */\nexport function initializeAutosave(): void {\n  // Save data when the window is about to unload\n  window.addEventListener('beforeunload', () => {\n    saveLearnedData();\n  });\n  \n  // Save data periodically (every 5 minutes)\n  setInterval(() => {\n    saveLearnedData();\n  }, 5 * 60 * 1000);\n  \n  // Attempt to load any existing data\n  loadLearnedData();\n}\n\n/**\n * Initialize the persistent learning system\n * This should be called once when the application starts\n */\nexport function initializePersistentLearning(): void {\n  // Try to load existing data\n  const dataLoaded = loadLearnedData();\n  \n  // If no data was loaded, initialize with default data\n  if (!dataLoaded) {\n    console.log('Initializing AI with default learning data');\n    // Default initialization is handled by the respective modules\n  }\n  \n  // Set up autosave\n  initializeAutosave();\n}","/**\n * Advanced AI Module for Tic Tac Toe\n * \n * This module integrates all the advanced AI algorithms into a cohesive system:\n * - Monte Carlo Tree Search for forward planning\n * - Bayesian opponent modeling for prediction\n * - Multi-armed bandit for strategy selection\n * - Persistent learning database for long-term improvement\n */\nimport type { Board, MoveResult, GameStyle } from './gameTypes';\nimport { findBestMoveMCTS } from './monteCarlo';\nimport { observeMove } from './bayesianModel';\nimport { getAdaptiveStrategyMove, recordGameOutcome } from './banditStrategies';\nimport { initializePersistentLearning, saveLearnedData } from './persistentLearning';\nimport { hasWinningMove } from './boardEvaluator';\n\n// Initialize the advanced AI system\nlet aiInitialized = false;\n\n/**\n * Initialize the advanced AI system\n */\nexport function initializeAdvancedAI(): void {\n  if (aiInitialized) return;\n  \n  // Initialize persistent learning\n  initializePersistentLearning();\n  \n  aiInitialized = true;\n  console.log('Advanced AI system initialized');\n}\n\n/**\n * Record a player's move for learning\n */\nexport function recordPlayerMoveAdvanced(\n  board: Board, \n  moveIndex: number\n): void {\n  // Initialize if not already done\n  if (!aiInitialized) {\n    initializeAdvancedAI();\n  }\n  \n  // Pass the move to the Bayesian model for learning\n  observeMove(board, moveIndex);\n}\n\n/**\n * Record game result for learning\n */\nexport function recordGameResultAdvanced(\n  winner: string | null, \n  aiPlayer: string\n): void {\n  // Initialize if not already done\n  if (!aiInitialized) {\n    initializeAdvancedAI();\n  }\n  \n  // Pass the result to the bandit system\n  recordGameOutcome(winner, aiPlayer);\n  \n  // Save the learned data\n  saveLearnedData();\n}\n\n/**\n * Get the best move using the advanced AI system\n */\nexport function findBestMoveAdvanced(\n  board: Board,\n  aiPlayer: string,\n  gameStyle: GameStyle = 'classic',\n  xMoves: number[] = [],\n  oMoves: number[] = [],\n  difficulty: string = 'hard'\n): MoveResult {\n  // Initialize if not already done\n  if (!aiInitialized) {\n    initializeAdvancedAI();\n  }\n  \n  // For easy difficulty, use simpler strategies\n  if (difficulty === 'easy') {\n    const opponent = aiPlayer === 'X' ? 'O' : 'X';\n    \n    // 80% chance to miss winning moves\n    if (Math.random() > 0.2) {\n      const winningMove = hasWinningMove(board, aiPlayer);\n      if (winningMove !== null) {\n        return winningMove;\n      }\n    }\n    \n    // 50% chance to miss blocking moves\n    if (Math.random() > 0.5) {\n      const blockingMove = hasWinningMove(board, opponent);\n      if (blockingMove !== null) {\n        return blockingMove;\n      }\n    }\n    \n    // Make random moves with preference for center and corners\n    const availableMoves = board\n      .map((cell, index) => cell === null ? index : -1)\n      .filter(index => index !== -1);\n    \n    // Prefer center\n    if (availableMoves.includes(4) && Math.random() > 0.3) {\n      return 4;\n    }\n    \n    // Otherwise make a random move\n    return availableMoves[Math.floor(Math.random() * availableMoves.length)];\n  }\n  \n  // For medium difficulty, occasionally make sub-optimal moves\n  if (difficulty === 'medium') {\n    // 70% chance to use advanced AI, 30% chance to use simpler approach\n    if (Math.random() > 0.3) {\n      return getAdaptiveStrategyMove(board, aiPlayer, gameStyle, xMoves, oMoves);\n    } else {\n      // Use MCTS with fewer iterations for medium difficulty\n      return findBestMoveMCTS(board, aiPlayer, 200);\n    }\n  }\n  \n  // For hard difficulty, use the full advanced AI system\n  return getAdaptiveStrategyMove(board, aiPlayer, gameStyle, xMoves, oMoves);\n}\n\n/**\n * Reset the AI's learning data\n * Useful for testing or when the player wants a fresh start\n */\nexport function resetAdvancedAI(): void {\n  import('./persistentLearning').then(module => {\n    module.resetLearnedData();\n  });\n}\n\n/**\n * Get statistics about the AI's learning\n * Useful for debugging and visualization\n */\nexport function getAIStats(): Promise<unknown> {\n  if (!aiInitialized) {\n    initializeAdvancedAI();\n  }\n  \n  // We need to use dynamic import for this function\n  // This returns a Promise, but since this is for debugging only, it's acceptable\n  return import('./persistentLearning').then(module => {\n    return module.getLearningStats();\n  });\n}","import { useState, useEffect, useCallback } from 'react';\nimport { findBestMove, findRandomMove } from '../utils/aiOpponent';\nimport { \n  findBestMoveAdvanced, \n  recordPlayerMoveAdvanced, \n  recordGameResultAdvanced,\n  initializeAdvancedAI\n} from '../utils/advancedAI';\nimport type { TicTacToe } from '../components/TicTacToe/TicTacToe';\n\nexport function useGameState(props: {\n  mode: TicTacToe.GameMode;\n  style: TicTacToe.GameStyle;\n  difficulty?: TicTacToe.Difficulty;\n  onGameEnd?: (winner: string | null) => void;\n}) {\n  const { mode, style, difficulty, onGameEnd } = props;\n\n  // Game state\n  const [board, setBoard] = useState<Array<string | null>>(Array(9).fill(null));\n  const [isXNext, setIsXNext] = useState<boolean>(true);\n  const [winner, setWinner] = useState<string | null>(null);\n  const [isAIThinking, setIsAIThinking] = useState<boolean>(false);\n  // Track move history for limited mode (3 moves per player)\n  const [xMoves, setXMoves] = useState<number[]>([]);\n  const [oMoves, setOMoves] = useState<number[]>([]);\n  const [highlightCell, setHighlightCell] = useState<number | null>(null);\n  // Track winning line indices\n  const [winningLine, setWinningLine] = useState<number[] | null>(null);\n\n  // AI player is always 'O', human is always 'X' in single player mode\n  const aiPlayer = 'O';\n\n  // Constants\n  const MAX_MOVES_PER_PLAYER = 3;\n\n  /**\n   * Calculate winner helper function - memoized for performance\n   */\n  const calculateWinner = useCallback((squares: Array<string | null>) => {\n    const lines = [\n      [0, 1, 2],\n      [3, 4, 5],\n      [6, 7, 8],\n      [0, 3, 6],\n      [1, 4, 7],\n      [2, 5, 8],\n      [0, 4, 8],\n      [2, 4, 6],\n    ];\n\n    for (const line of lines) {\n      const [a, b, c] = line;\n      if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n        return { winner: squares[a], line: line };\n      }\n    }\n\n    return { winner: null, line: null };\n  }, []);\n\n  /**\n   * Reset game state\n   * @param initialMove Optional index to place a move right after resetting\n   */\n  const resetGame = useCallback((initialMove?: number) => {\n    // Record game outcome if we're resetting mid-game\n    if (mode === 'single' && board.some(cell => cell !== null) && !winner) {\n      // Treat abandoning a game as a loss for learning purposes\n      recordGameResultAdvanced('X', aiPlayer);\n    }\n    \n    // Reset all state variables\n    const newBoard = Array(9).fill(null);\n    setBoard(newBoard);\n    setIsXNext(true);\n    setWinner(null);\n    setIsAIThinking(false);\n    setXMoves([]);\n    setOMoves([]);\n    setHighlightCell(null);\n    setWinningLine(null);\n\n    // If an initial move was provided, place it after resetting\n    if (initialMove !== undefined && initialMove >= 0 && initialMove < 9) {\n      // Small delay to ensure state is updated before placing the move\n      setTimeout(() => {\n        // Update the board with the new move (player X always starts)\n        const updatedBoard = [...newBoard];\n        updatedBoard[initialMove] = 'X';\n        setBoard(updatedBoard);\n\n        // Update moves history for limited mode\n        if (style === 'limited') {\n          setXMoves([initialMove]);\n        }\n\n        // Set next player to O\n        setIsXNext(false);\n      }, 10);\n    }\n  }, [style, mode, board, winner, aiPlayer]);\n\n\n  /**\n   * AI move handler\n   */\n  const makeAIMove = useCallback(() => {\n    // If game is over or not AI's turn, do nothing\n    if (winner || isXNext) {\n      return;\n    }\n\n    // In classic mode, also return if board is full\n    if (style === 'classic' && board.every(square => square !== null)) {\n      return;\n    }\n\n    setIsAIThinking(true);\n\n    // Add a small delay to simulate \"thinking\"\n    setTimeout(() => {\n      const newBoard = [...board];\n      let moveIndex: number;\n\n      // Choose AI move based on difficulty\n      switch (difficulty) {\n        case 'easy':\n          moveIndex = findRandomMove(newBoard, aiPlayer, style, xMoves, oMoves);\n          break;\n        case 'medium':\n          // 50% chance to make a random move, 50% chance to make the best move\n          moveIndex = Math.random() > 0.5\n            ? findRandomMove(newBoard, aiPlayer, style, xMoves, oMoves)\n            : findBestMove(newBoard, aiPlayer, style, xMoves, oMoves, difficulty);\n          break;\n        case 'hard':\n        default:\n          // Use the advanced AI system with all learning algorithms integrated\n          moveIndex = findBestMoveAdvanced(newBoard, aiPlayer, style, xMoves, oMoves, difficulty);\n          break;\n      }\n\n      if (moveIndex >= 0) {\n        // Limited mode special handling for AI\n        if (style === 'limited') {\n          // If AI already has MAX_MOVES_PER_PLAYER moves, remove the oldest one\n          if (oMoves.length >= MAX_MOVES_PER_PLAYER) {\n            const oldestMoveIndex = oMoves[0];\n            newBoard[oldestMoveIndex] = null;\n\n            // Update O moves array (remove oldest and add new)\n            setOMoves(prevMoves => [...prevMoves.slice(1), moveIndex]);\n          } else {\n            // Just add the new move\n            setOMoves(prevMoves => [...prevMoves, moveIndex]);\n          }\n        }\n\n        // Update the board with AI's move\n        newBoard[moveIndex] = aiPlayer;\n        setBoard(newBoard);\n\n        // Check for winner\n        const result = calculateWinner(newBoard);\n        if (result.winner) {\n          setWinner(result.winner);\n          setWinningLine(result.line);\n          onGameEnd?.(result.winner);\n        } else if (style === 'classic' && newBoard.every(square => square !== null)) {\n          // Draw case in classic mode only\n          onGameEnd?.(null);\n        }\n      }\n\n      setIsXNext(true);\n      setIsAIThinking(false);\n    }, 500);\n  }, [board, isXNext, winner, style, difficulty, oMoves, calculateWinner, onGameEnd, xMoves]);\n\n  /**\n   * Effect to trigger AI move when it's AI's turn in single player mode\n   */\n  // Initialize advanced AI when the hook is first used\n  useEffect(() => {\n    if (mode === 'single') {\n      initializeAdvancedAI();\n    }\n  }, [mode]);\n  \n  useEffect(() => {\n    if (mode === 'single' && !isXNext && !winner) {\n      makeAIMove();\n    }\n  }, [isXNext, winner, mode, makeAIMove]);\n\n  /**\n   * Effect to highlight the next piece to be removed in limited mode\n   */\n  useEffect(() => {\n    // Don't highlight any cell if there's a winner or if not in limited mode\n    if (winner || style !== 'limited') {\n      setHighlightCell(null);\n      return;\n    }\n\n    // Highlight the oldest piece for the next player (only if no winner)\n    if (isXNext && xMoves.length === MAX_MOVES_PER_PLAYER) {\n      setHighlightCell(xMoves[0]);\n    } else if (!isXNext && oMoves.length === MAX_MOVES_PER_PLAYER) {\n      setHighlightCell(oMoves[0]);\n    } else {\n      setHighlightCell(null);\n    }\n  }, [isXNext, xMoves, oMoves, style, winner]);\n\n  /**\n   * Handle human player click\n   */\n  const handleClick = useCallback((index: number) => {\n    // If there's a winner, start a new game and place a move at the clicked position\n    if (winner) {\n      resetGame(index);\n      return;\n    }\n\n    // If square is occupied, AI is thinking, or it's AI's turn, do nothing\n    if (board[index] || (mode === 'single' && !isXNext) || isAIThinking) {\n      return;\n    }\n\n    const currentPlayer = isXNext ? 'X' : 'O';\n    const currentMoves = isXNext ? xMoves : oMoves;\n    const newBoard = [...board];\n\n    // Limited mode special handling\n    if (style === 'limited') {\n      // If player already has MAX_MOVES_PER_PLAYER moves, remove the oldest one\n      if (currentMoves.length >= MAX_MOVES_PER_PLAYER) {\n        const oldestMoveIndex = currentMoves[0];\n        newBoard[oldestMoveIndex] = null;\n\n        // Update the moves array (remove oldest and add new)\n        if (isXNext) {\n          setXMoves(prevMoves => [...prevMoves.slice(1), index]);\n        } else {\n          setOMoves(prevMoves => [...prevMoves.slice(1), index]);\n        }\n      } else {\n        // Just add the new move\n        if (isXNext) {\n          setXMoves(prevMoves => [...prevMoves, index]);\n        } else {\n          setOMoves(prevMoves => [...prevMoves, index]);\n        }\n      }\n    }\n\n    // Update the board with the new move\n    newBoard[index] = currentPlayer;\n    setBoard(newBoard);\n    \n    // Record the move for AI learning (only in single player mode when human player makes a move)\n    if (mode === 'single' && currentPlayer === 'X') {\n      // Use the advanced AI learning system\n      recordPlayerMoveAdvanced([...newBoard], index);\n    }\n\n    // Check for winner\n    const result = calculateWinner(newBoard);\n    if (result.winner) {\n      setWinner(result.winner);\n      setWinningLine(result.line);\n      \n      // Record game result for AI learning when game ends\n      if (mode === 'single') {\n        recordGameResultAdvanced(result.winner, aiPlayer);\n      }\n      \n      onGameEnd?.(result.winner);\n    } else {\n      // In classic mode, check for draw when board is full\n      // In limited mode, we never reach a draw by filling the board\n      if (style === 'classic' && newBoard.every(square => square !== null)) {\n        // Draw case - also record this result for AI learning\n        if (mode === 'single') {\n          recordGameResultAdvanced(null, aiPlayer);\n        }\n        onGameEnd?.(null);\n      } else {\n        setIsXNext(!isXNext);\n      }\n    }\n  }, [board, winner, mode, isXNext, isAIThinking, style, xMoves, oMoves, calculateWinner, onGameEnd, resetGame]);\n\n  // Check if the game is a draw\n  const isDraw = style === 'classic' && board.every(square => square !== null) && !winner;\n\n  return {\n    board,\n    isXNext,\n    winner,\n    isAIThinking,\n    xMoves,\n    oMoves,\n    highlightCell,\n    winningLine,\n    isDraw,\n    handleClick,\n    resetGame\n  };\n}","import React, { useEffect, useState } from 'react';\nimport './styles.css';\n\nexport namespace Confetti {\n  export type Props = {\n    active: boolean;\n  }\n}\n\nexport function Confetti(props: Confetti.Props) {\n  /**\n   * State vars\n   */\n  const [confettiElements, setConfettiElements] = useState<React.ReactNode[]>([]);\n  \n  /**\n   * Side effects\n   */\n  useEffect(() => {\n    if (props.active) {\n      const elements: React.ReactNode[] = [];\n      const colors = [\n        '#FF3855', '#FD5B78', '#FF6037', '#FF9966', '#FF9933', \n        '#FFCC33', '#FFFF66', '#CCFF00', '#66FF66', '#AAF0D1',\n        '#50BFE6', '#FF6EFF', '#EE34D2', '#FF00CC', '#FF00CC',\n        '#9C51B6', '#A0D6B4', '#00FFFF', '#5946B2', '#E936A7'\n      ];\n      \n      // Create multiple confetti elements - significantly increased for better coverage\n      for (let i = 0; i < 500; i++) {\n        // More consistent distance from center for smoother animation\n        // Use linear distribution instead of tiered distances\n        const minDistance = 100;\n        const maxDistance = 800;\n        const distance = minDistance + Math.random() * (maxDistance - minDistance);\n        const angle = Math.random() * 360; // Angle in degrees\n        const randomX = distance * Math.cos(angle * Math.PI / 180);\n        const randomY = distance * Math.sin(angle * Math.PI / 180);\n        \n        // Slightly reduced random delay range for more simultaneous movement\n        const animationDelay = `${Math.random() * 0.2}s`;\n        const randomSpeed = Math.random();\n        \n        // Mostly smaller confetti pieces with occasional larger ones\n        const sizes = [\n          Math.floor(Math.random() * 6) + 4,     // Small: 4-10px (70% chance)\n          Math.floor(Math.random() * 10) + 8,    // Medium: 8-18px (25% chance)\n          Math.floor(Math.random() * 12) + 15    // Large: 15-27px (5% chance)\n        ];\n        const sizeRoll = Math.random();\n        const size = sizeRoll < 0.7 ? sizes[0] : (sizeRoll < 0.95 ? sizes[1] : sizes[2]);\n        \n        // Random rotation\n        const rotateAmount = -180 + Math.random() * 360;\n        \n        // Random color from our expanded palette\n        const color = colors[Math.floor(Math.random() * colors.length)];\n        \n        // Random shape - with more varieties\n        const shapeTypes = ['square', 'circle', 'triangle', 'star', 'heart'];\n        const shape = shapeTypes[Math.floor(Math.random() * shapeTypes.length)];\n        \n        // Create a custom CSS Properties type with our custom properties\n        interface CustomCSSProperties extends React.CSSProperties {\n          '--random-x': string;\n          '--random-y': string;\n          '--random-rotate': string;\n          '--random-speed': string;\n          '--triangle-color'?: string;\n          '--heart-color'?: string;\n        }\n        \n        // Set CSS variables for the explosion effect\n        const style: CustomCSSProperties = {\n          '--random-x': `${randomX}px`,\n          '--random-y': `${randomY}px`,\n          '--random-rotate': `${rotateAmount}deg`,\n          '--random-speed': randomSpeed.toString(),\n          backgroundColor: color,\n          width: `${size}px`,\n          height: `${size}px`,\n          animationDelay,\n        };\n        \n        // For triangle and heart shapes\n        if (shape === 'triangle') {\n          style['--triangle-color'] = color;\n          style.backgroundColor = 'transparent';\n        } else if (shape === 'heart') {\n          style['--heart-color'] = color;\n          style.backgroundColor = 'transparent';\n        }\n        \n        elements.push(\n          <div\n            key={i}\n            className={`confetti-piece ${shape}`}\n            style={style}\n          />\n        );\n      }\n      \n      setConfettiElements(elements);\n      \n      // Clean up after animation ends\n      const timer = setTimeout(() => {\n        setConfettiElements([]);\n      }, 3500); // Adjusted for smoother animation duration\n      \n      return () => {\n        clearTimeout(timer);\n      };\n    } else {\n      setConfettiElements([]);\n    }\n  }, [props.active]);\n  \n  /**\n   * Render\n   */\n  if (!props.active && confettiElements.length === 0) {\n    return null;\n  }\n  \n  return (\n    <div className=\"confetti-container\">\n      {confettiElements}\n    </div>\n  );\n}","import { memo } from 'react';\n\nexport namespace Square {\n  export type Props = {\n    value: string | null;\n    onClick: () => void;\n    isHighlighted: boolean;\n    isWinningSquare: boolean;\n    index: number;\n  };\n}\n\n/**\n * Individual square component for the Tic Tac Toe board\n */\nexport const Square = memo(function Square(props: Square.Props) {\n  const { value, onClick, isHighlighted, isWinningSquare, index } = props;\n  \n  // Compute class name based on props\n  const squareClassName = `square ${isHighlighted ? 'highlighted' : ''} ${isWinningSquare ? 'winning' : ''}`;\n  \n  // Render SVG X and O with animation\n  const renderSymbol = () => {\n    if (!value) return null;\n    \n    if (value === 'X') {\n      return (\n        <svg className=\"symbol-svg\" viewBox=\"0 0 80 80\" preserveAspectRatio=\"xMidYMid meet\">\n          {/* First stroke of X */}\n          <path \n            className=\"symbol-path x-symbol-1\" \n            d=\"M20,20 L60,60\"\n            stroke=\"#3498db\"\n            strokeWidth=\"12\"\n            strokeLinecap=\"round\"\n          />\n          {/* Second stroke of X */}\n          <path \n            className=\"symbol-path x-symbol-2\" \n            d=\"M60,20 L20,60\"\n            stroke=\"#3498db\"\n            strokeWidth=\"12\"\n            strokeLinecap=\"round\"\n          />\n        </svg>\n      );\n    } else {\n      return (\n        <svg className=\"symbol-svg\" viewBox=\"0 0 80 80\" preserveAspectRatio=\"xMidYMid meet\">\n          <circle \n            className=\"symbol-path o-symbol\" \n            cx=\"40\" \n            cy=\"40\" \n            r=\"25\"\n            stroke=\"#e74c3c\"\n            strokeWidth=\"12\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n            fill=\"none\"\n          />\n        </svg>\n      );\n    }\n  };\n  \n  return (\n    <button\n      className={squareClassName}\n      onClick={onClick}\n      aria-label={`Square ${index}`}\n    >\n      {renderSymbol()}\n      {isHighlighted && <span className=\"removal-indicator\">↻</span>}\n    </button>\n  );\n});","import { memo } from 'react';\nimport { Square } from './Square';\n\nexport namespace Board {\n  export type Props = {\n    board: Array<string | null>;\n    highlightCell: number | null;\n    winningLine: number[] | null;\n    onSquareClick: (index: number) => void;\n  };\n}\n\n/**\n * Game board component that renders the 3x3 grid of squares\n */\nexport const Board = memo(function Board(props: Board.Props) {\n  const { board, highlightCell, winningLine, onSquareClick } = props;\n  \n  // Create a square component with the right props\n  const renderSquare = (index: number) => {\n    // Only highlight if there's no winner yet\n    const isHighlighted = highlightCell === index;\n    // Check if this square is part of the winning line\n    const isWinningSquare = winningLine?.includes(index) || false;\n    \n    return (\n      <Square\n        key={index}\n        value={board[index]}\n        onClick={() => onSquareClick(index)}\n        isHighlighted={isHighlighted}\n        isWinningSquare={isWinningSquare}\n        index={index}\n      />\n    );\n  };\n  \n  return (\n    <div className=\"board\">\n      <div className=\"board-row\">\n        {renderSquare(0)}\n        {renderSquare(1)}\n        {renderSquare(2)}\n      </div>\n      <div className=\"board-row\">\n        {renderSquare(3)}\n        {renderSquare(4)}\n        {renderSquare(5)}\n      </div>\n      <div className=\"board-row\">\n        {renderSquare(6)}\n        {renderSquare(7)}\n        {renderSquare(8)}\n      </div>\n    </div>\n  );\n});","import { memo } from 'react';\n\nexport namespace Status {\n  export type Props = {\n    winner: string | null;\n    isAIThinking: boolean;\n    isXNext: boolean;\n    isDraw: boolean;\n  };\n}\n\n/**\n * Game status component that displays the current game state\n */\nexport const Status = memo(function Status(props: Status.Props) {\n  const { winner, isAIThinking, isXNext, isDraw } = props;\n  \n  let statusText: string;\n  \n  if (winner) {\n    statusText = `Winner: ${winner}`;\n  } else if (isDraw) {\n    statusText = 'Game ended in a draw';\n  } else if (isAIThinking) {\n    statusText = 'AI is thinking...';\n  } else {\n    const currentPlayer = isXNext ? 'X' : 'O';\n    statusText = `Next player: ${currentPlayer}`;\n  }\n  \n  return <div className=\"status\">{statusText}</div>;\n});","import { memo } from 'react';\n\nexport namespace WinningLine {\n  export type Props = {\n    winningLine: number[] | null;\n  };\n}\n\n/**\n * Component that renders the winning line across the board\n */\nexport const WinningLine = memo(function WinningLine(props: WinningLine.Props) {\n  const { winningLine } = props;\n  \n  if (!winningLine) return null;\n  \n  // Horizontal rows\n  if (winningLine.toString() === [0, 1, 2].toString()) return <div className=\"winning-line row-1\"></div>;\n  if (winningLine.toString() === [3, 4, 5].toString()) return <div className=\"winning-line row-2\"></div>;\n  if (winningLine.toString() === [6, 7, 8].toString()) return <div className=\"winning-line row-3\"></div>;\n  \n  // Vertical columns\n  if (winningLine.toString() === [0, 3, 6].toString()) return <div className=\"winning-line col-1\"></div>;\n  if (winningLine.toString() === [1, 4, 7].toString()) return <div className=\"winning-line col-2\"></div>;\n  if (winningLine.toString() === [2, 5, 8].toString()) return <div className=\"winning-line col-3\"></div>;\n  \n  // Diagonals - use SVG for these\n  if (winningLine.toString() === [0, 4, 8].toString()) {\n    return (\n      <svg className=\"winning-line-svg\" viewBox=\"0 0 244 244\" preserveAspectRatio=\"none\">\n        <defs>\n          <linearGradient id=\"greenGradient\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\">\n            <stop offset=\"0%\"   stopColor=\"#4CAF50\" />\n            <stop offset=\"25%\"  stopColor=\"#66BB6A\" />\n            <stop offset=\"50%\"  stopColor=\"#4CAF50\" />\n            <stop offset=\"75%\"  stopColor=\"#388E3C\" />\n            <stop offset=\"100%\" stopColor=\"#4CAF50\" />\n          </linearGradient>\n        </defs>\n        <line x1=\"10\" y1=\"10\" x2=\"234\" y2=\"234\" className=\"diagonal-line\" />\n      </svg>\n    );\n  }\n  \n  if (winningLine.toString() === [2, 4, 6].toString()) {\n    return (\n      <svg className=\"winning-line-svg\" viewBox=\"0 0 244 244\" preserveAspectRatio=\"none\">\n        <defs>\n          <linearGradient id=\"greenGradient\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\">\n            <stop offset=\"0%\"   stopColor=\"#4CAF50\" />\n            <stop offset=\"25%\"  stopColor=\"#66BB6A\" />\n            <stop offset=\"50%\"  stopColor=\"#4CAF50\" />\n            <stop offset=\"75%\"  stopColor=\"#388E3C\" />\n            <stop offset=\"100%\" stopColor=\"#4CAF50\" />\n          </linearGradient>\n        </defs>\n        <line x1=\"234\" y1=\"10\" x2=\"10\" y2=\"234\" className=\"diagonal-line\" />\n      </svg>\n    );\n  }\n  \n  return null;\n});","import { memo, useCallback } from 'react';\nimport { useGameState } from '../../hooks/useGameState';\nimport { Confetti } from '../Confetti';\nimport { Board } from './Board';\nimport { Status } from './Status';\nimport { WinningLine } from './WinningLine';\nimport './styles.css';\n\nexport namespace TicTacToe {\n  export type GameMode = 'single' | 'multi';\n  export type Difficulty = 'easy' | 'medium' | 'hard';\n  export type GameStyle = 'classic' | 'limited';\n\n  export type Props = {\n    mode: GameMode;\n    style: GameStyle;\n    difficulty?: Difficulty;\n    onGameEnd?: (winner: string | null) => void;\n  }\n}\n\nexport const TicTacToe = memo(function TicTacToe(props: TicTacToe.Props) {\n  // Use custom hook to manage game state\n  const {\n    board,\n    isXNext,\n    winner,\n    isAIThinking,\n    highlightCell,\n    winningLine,\n    isDraw,\n    handleClick,\n    resetGame\n  } = useGameState(props);\n\n  // Memoized click handler to optimize renders\n  const handleSquareClick = useCallback((index: number) => {\n    handleClick(index);\n  }, [handleClick]);\n\n  return (\n    <div className=\"tic-tac-toe\">\n      {/* Show confetti when there's a winner */}\n      <Confetti active={!!winner} />\n      \n      {/* Status message */}\n      <Status\n        winner={winner}\n        isAIThinking={isAIThinking}\n        isXNext={isXNext}\n        isDraw={isDraw}\n      />\n\n      {/* Game board container */}\n      <div className=\"board-container\">\n        <WinningLine winningLine={winningLine} />\n        <Board\n          board={board}\n          highlightCell={highlightCell}\n          winningLine={winningLine}\n          onSquareClick={handleSquareClick}\n        />\n      </div>\n\n      {/* Reset/New Game button */}\n      <button \n        className=\"reset-button\" \n        onClick={() => resetGame()}\n      >\n        {winner ? 'New Game' : 'Reset Game'}\n      </button>\n    </div>\n  );\n});"],"file":"assets/game-D5yP27q4.js"}