{"version":3,"file":"utils-D3OVl5Gg.js","sources":["../../src/utils/limitedModeAI.ts","../../src/utils/aiOpponent.ts"],"sourcesContent":["/**\n * Specialized AI strategies for the limited mode (3 moves per player)\n */\nimport type { Board } from './gameTypes';\nimport { hasWinningMove, hasForkMove, evaluateLimitedModePosition } from './boardEvaluator';\n\nconst MAX_MOVES_PER_PLAYER = 3;\n\n/**\n * Finds the best move for the AI in limited mode\n */\nexport function findBestLimitedMove(\n  board: Board,\n  aiPlayer: string,\n  xMoves: number[],\n  oMoves: number[]\n): number {\n  const humanPlayer = aiPlayer === 'X' ? 'O' : 'X';\n  const aiMoves = aiPlayer === 'X' ? xMoves : oMoves;\n  const humanMoves = aiPlayer === 'X' ? oMoves : xMoves;\n\n  // 1. Check if AI can win immediately\n  const winningMove = hasWinningMove(board, aiPlayer);\n  if (winningMove !== null) {\n    return winningMove;\n  }\n\n  // 2. Check if need to block human from winning\n  const blockingMove = hasWinningMove(board, humanPlayer);\n  if (blockingMove !== null) {\n    return blockingMove;\n  }\n\n  // 3. Special limited mode strategy\n  return limitedModeStrategy(board, aiPlayer, aiMoves, humanMoves);\n}\n\n/**\n * Strategic move selection for limited mode\n */\nfunction limitedModeStrategy(\n  board: Board,\n  aiPlayer: string,\n  aiMoves: number[],\n  humanMoves: number[]\n): number {\n  const humanPlayer = aiPlayer === 'X' ? 'O' : 'X';\n\n  // Get all empty cell indices\n  const emptyCells = board\n    .map((cell, index) => cell === null ? index : -1)\n    .filter(index => index !== -1);\n\n  // If AI already has max moves, we need to consider replacing one\n  if (aiMoves.length >= MAX_MOVES_PER_PLAYER) {\n    // The move to be replaced is the oldest one (first in the array)\n    const moveToReplace = aiMoves[0];\n\n    // Try each empty cell and evaluate\n    let bestScore = -Infinity;\n    let bestMove = emptyCells[0] || 0; // Default to first empty if somehow none\n\n    for (const emptyCell of emptyCells) {\n      // Simulate making this move and removing the oldest\n      const simulatedBoard = [...board];\n      simulatedBoard[moveToReplace] = null;  // Remove oldest\n      simulatedBoard[emptyCell] = aiPlayer;  // Place new\n\n      // Calculate new moves arrays for evaluation\n      const newAiMoves = [...aiMoves.slice(1), emptyCell];\n\n      // Evaluate this position with deeper search\n      const score = evaluateWithLookahead(\n        simulatedBoard,\n        aiPlayer,\n        humanPlayer,\n        newAiMoves,\n        humanMoves,\n        2 // Lookahead depth\n      );\n\n      if (score > bestScore) {\n        bestScore = score;\n        bestMove = emptyCell;\n      }\n    }\n\n    return bestMove;\n  }\n  // If AI has fewer than max moves, we can place anywhere\n  else {\n    // If center is empty, take it\n    if (board[4] === null) {\n      return 4;\n    }\n\n    // Try to create a fork\n    const forkMove = hasForkMove(board, aiPlayer);\n    if (forkMove !== null) {\n      return forkMove;\n    }\n\n    // Block opponent's fork\n    const blockForkMove = hasForkMove(board, humanPlayer);\n    if (blockForkMove !== null) {\n      return blockForkMove;\n    }\n\n    // Evaluate each empty cell\n    let bestScore = -Infinity;\n    let bestMove = emptyCells[0] || 0;\n\n    for (const emptyCell of emptyCells) {\n      const simulatedBoard = [...board];\n      simulatedBoard[emptyCell] = aiPlayer;\n\n      // Calculate new moves arrays for evaluation\n      const newAiMoves = [...aiMoves, emptyCell];\n\n      // Evaluate this position with lookahead\n      const score = evaluateWithLookahead(\n        simulatedBoard,\n        aiPlayer,\n        humanPlayer,\n        newAiMoves,\n        humanMoves,\n        2 // Lookahead depth\n      );\n\n      if (score > bestScore) {\n        bestScore = score;\n        bestMove = emptyCell;\n      }\n    }\n\n    return bestMove;\n  }\n}\n\n/**\n * Evaluates a position with lookahead for future moves\n */\nfunction evaluateWithLookahead(\n  board: Board,\n  aiPlayer: string,\n  humanPlayer: string,\n  aiMoves: number[],\n  humanMoves: number[],\n  depth: number\n): number {\n  // Base case: if at depth 0 or game is over, return evaluation\n  if (depth === 0 || isGameOver(board)) {\n    return evaluateLimitedModePosition(\n      board,\n      aiPlayer,\n      humanPlayer,\n      aiMoves,\n      humanMoves,\n      MAX_MOVES_PER_PLAYER\n    );\n  }\n\n  // Get all empty cells\n  const emptyCells = board\n    .map((cell, index) => cell === null ? index : -1)\n    .filter(index => index !== -1);\n\n  // If AI's turn (maximizing)\n  if (depth % 2 === 0) {\n    let maxScore = -Infinity;\n\n    // Try each possible move\n    for (const emptyCell of emptyCells) {\n      // If AI already has max moves, need to remove oldest\n      const newBoard = [...board];\n      let newAiMoves = [...aiMoves];\n\n      if (aiMoves.length >= MAX_MOVES_PER_PLAYER) {\n        const oldestMove = aiMoves[0];\n        newBoard[oldestMove] = null;\n        newBoard[emptyCell] = aiPlayer;\n        newAiMoves = [...aiMoves.slice(1), emptyCell];\n      } else {\n        newBoard[emptyCell] = aiPlayer;\n        newAiMoves = [...aiMoves, emptyCell];\n      }\n\n      // Recursive evaluation\n      const score = evaluateWithLookahead(\n        newBoard,\n        aiPlayer,\n        humanPlayer,\n        newAiMoves,\n        humanMoves,\n        depth - 1\n      );\n\n      maxScore = Math.max(maxScore, score);\n    }\n\n    return maxScore;\n  }\n  // Human's turn (minimizing)\n  else {\n    let minScore = Infinity;\n\n    // Try each possible move\n    for (const emptyCell of emptyCells) {\n      // If human already has max moves, need to remove oldest\n      const newBoard = [...board];\n      let newHumanMoves = [...humanMoves];\n\n      if (humanMoves.length >= MAX_MOVES_PER_PLAYER) {\n        const oldestMove = humanMoves[0];\n        newBoard[oldestMove] = null;\n        newBoard[emptyCell] = humanPlayer;\n        newHumanMoves = [...humanMoves.slice(1), emptyCell];\n      } else {\n        newBoard[emptyCell] = humanPlayer;\n        newHumanMoves = [...humanMoves, emptyCell];\n      }\n\n      // Recursive evaluation\n      const score = evaluateWithLookahead(\n        newBoard,\n        aiPlayer,\n        humanPlayer,\n        aiMoves,\n        newHumanMoves,\n        depth - 1\n      );\n\n      minScore = Math.min(minScore, score);\n    }\n\n    return minScore;\n  }\n}\n\n/**\n * Checks if the game is over (win or full board)\n */\nfunction isGameOver(board: Board): boolean {\n  // Check for win\n  const lines = [\n    [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows\n    [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns\n    [0, 4, 8], [2, 4, 6]             // diagonals\n  ];\n\n  for (const [a, b, c] of lines) {\n    if (board[a] && board[a] === board[b] && board[a] === board[c]) {\n      return true; // Win\n    }\n  }\n\n  // In limited mode, the board is never technically full since we keep removing pieces\n  // But we can consider a certain number of moves as endgame\n  return false;\n}","/**\n * AI Opponent utilities for Tic Tac Toe\n * Optimized with memoization, advanced strategies, and adaptive learning\n */\nimport { findBestLimitedMove } from './limitedModeAI';\nimport { hasWinningMove, hasForkMove } from './boardEvaluator';\nimport type { Board, MoveResult, GameStyle } from './gameTypes';\nimport { getBayesianCounterMove } from './bayesianModel';\n\n// Cache for minimax results to avoid recalculating the same positions\nconst minimaxCache = new Map<string, number>();\n\n/**\n * Create a hash key from board state for caching\n */\nfunction getBoardHash(board: Board, isMaximizing: boolean, depth: number): string {\n  return `${board.join('')}|${isMaximizing}|${depth}`;\n}\n\n/**\n * Finds the best move for the AI using the minimax algorithm with memoization\n * @param gameStyle - The style of game being played (classic or limited)\n * @param xMoves - Array of X's moves (for limited mode)\n * @param oMoves - Array of O's moves (for limited mode)\n */\nexport function findBestMove(\n  board: Board,\n  aiPlayer: string,\n  gameStyle: GameStyle = 'classic',\n  xMoves: number[] = [],\n  oMoves: number[] = [],\n  difficulty: string = 'medium'\n): MoveResult {\n  // For limited mode, use specialized algorithm\n  if (gameStyle === 'limited') {\n    return findBestLimitedMove(board, aiPlayer, xMoves, oMoves);\n  }\n\n  // Reset cache for new board evaluation to prevent memory leaks\n  if (minimaxCache.size > 1000) {\n    minimaxCache.clear();\n  }\n\n  // Check for empty spaces\n  const emptyIndices = board\n    .map((square, index) => (square === null ? index : null))\n    .filter((index): index is number => index !== null);\n\n  // If no empty spaces, return -1\n  if (emptyIndices.length === 0) {\n    return -1;\n  }\n\n  // If only one empty space, return it\n  if (emptyIndices.length === 1) {\n    return emptyIndices[0];\n  }\n\n  // Human player is the opposite of AI player\n  const humanPlayer = aiPlayer === 'X' ? 'O' : 'X';\n\n  // Strategy optimizations for first few moves\n  // 1. Check for immediate win\n  const winningMove = hasWinningMove(board, aiPlayer);\n  if (winningMove !== null) {\n    return winningMove;\n  }\n\n  // 2. Check if need to block opponent from winning\n  const blockingMove = hasWinningMove(board, humanPlayer);\n  if (blockingMove !== null) {\n    return blockingMove;\n  }\n\n  // 3. For medium and hard mode, use adaptive learning to predict player moves\n  const adaptiveMove = getBayesianCounterMove(board);\n  if (adaptiveMove !== null) {\n    // Different adaptation rates based on difficulty\n    if (difficulty === 'hard' && Math.random() < 0.9) {\n      // 90% chance to use adaptive moves in hard mode\n      return adaptiveMove;\n    } else if (difficulty === 'medium' && Math.random() < 0.5) {\n      // 50% chance to use adaptive moves in medium mode\n      return adaptiveMove;\n    }\n  }\n\n  // 4. Check for fork opportunity\n  const forkMove = hasForkMove(board, aiPlayer);\n  if (forkMove !== null) {\n    return forkMove;\n  }\n\n  // 5. Check if need to block opponent's fork\n  const blockForkMove = hasForkMove(board, humanPlayer);\n  if (blockForkMove !== null) {\n    return blockForkMove;\n  }\n\n  // 6. Take center if empty\n  if (board[4] === null) {\n    return 4;\n  }\n\n  // Fall back to minimax for deeper evaluation\n  // Initialize best move and score\n  let bestMove: number = -1;\n  let bestScore = -Infinity;\n\n  // Try each empty space\n  for (const index of emptyIndices) {\n    // Make the move\n    board[index] = aiPlayer;\n\n    // Calculate score for this move with memoization\n    const score = minimax(board, 0, false, aiPlayer, humanPlayer);\n\n    // Undo the move\n    board[index] = null;\n\n    // If better score, update best score and move\n    if (score > bestScore) {\n      bestScore = score;\n      bestMove = index;\n    }\n  }\n\n  return bestMove;\n}\n\n/**\n * Minimax algorithm for determining the best move with alpha-beta pruning and deeper search\n */\nfunction minimax(\n  board: Board,\n  depth: number, // Increased depth for harder AI\n  isMaximizing: boolean,\n  aiPlayer: string,\n  humanPlayer: string,\n  alpha: number = -Infinity,\n  beta: number = Infinity,\n): number {\n  // Create a cache key for this board state\n  const cacheKey = getBoardHash(board, isMaximizing, depth);\n\n  // Check if we've already calculated this position\n  if (minimaxCache.has(cacheKey)) {\n    return minimaxCache.get(cacheKey)!;\n  }\n\n  // Check if game is over\n  const winner = checkWinner(board);\n  if (winner !== null) {\n    const score = winner === aiPlayer ? 10 - depth : depth - 10;\n    minimaxCache.set(cacheKey, score);\n    return score;\n  }\n\n  // Check if board is full (draw)\n  if (!board.includes(null)) {\n    minimaxCache.set(cacheKey, 0);\n    return 0;\n  }\n\n  // Maximizing player (AI)\n  if (isMaximizing) {\n    let bestScore = -Infinity;\n    for (let i = 0; i < board.length; i++) {\n      if (board[i] === null) {\n        board[i] = aiPlayer;\n        const score = minimax(board, depth + 1, false, aiPlayer, humanPlayer, alpha, beta);\n        board[i] = null;\n        bestScore = Math.max(score, bestScore);\n        alpha = Math.max(alpha, bestScore);\n        if (beta <= alpha) break; // Alpha-beta pruning\n      }\n    }\n    minimaxCache.set(cacheKey, bestScore);\n    return bestScore;\n  }\n  // Minimizing player (Human)\n  else {\n    let bestScore = Infinity;\n    for (let i = 0; i < board.length; i++) {\n      if (board[i] === null) {\n        board[i] = humanPlayer;\n        const score = minimax(board, depth + 1, true, aiPlayer, humanPlayer, alpha, beta);\n        board[i] = null;\n        bestScore = Math.min(score, bestScore);\n        beta = Math.min(beta, bestScore);\n        if (beta <= alpha) break; // Alpha-beta pruning\n      }\n    }\n    minimaxCache.set(cacheKey, bestScore);\n    return bestScore;\n  }\n}\n\n/**\n * Check if there is a winner on the board\n */\nfunction checkWinner(board: Board): string | null {\n  const lines = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6],\n  ];\n\n  for (const [a, b, c] of lines) {\n    if (board[a] && board[a] === board[b] && board[a] === board[c]) {\n      return board[a];\n    }\n  }\n\n  return null;\n}\n\n/**\n * Returns a random valid move but prefers winning moves (for easy difficulty)\n */\nexport function findRandomMove(\n  board: Board,\n  aiPlayer: string = 'O',\n  gameStyle: GameStyle = 'classic',\n  xMoves: number[] = [],\n  oMoves: number[] = []\n): MoveResult {\n  const humanPlayer = aiPlayer === 'X' ? 'O' : 'X';\n\n  // Even on easy, the AI should take obvious wins\n  const winningMove = hasWinningMove(board, aiPlayer);\n  if (winningMove !== null && Math.random() > 0.2) { // 80% chance to take the win\n    return winningMove;\n  }\n\n  // 50% chance to block an obvious loss\n  const blockingMove = hasWinningMove(board, humanPlayer);\n  if (blockingMove !== null && Math.random() > 0.5) {\n    return blockingMove;\n  }\n\n  // For limited mode with full moves, prefer replacing the oldest move\n  if (gameStyle === 'limited') {\n    const aiMoves = aiPlayer === 'X' ? xMoves : oMoves;\n    if (aiMoves.length >= 3) {\n      const emptyIndices = board\n        .map((square, index) => (square === null ? index : null))\n        .filter((index): index is number => index !== null);\n\n      if (emptyIndices.length > 0) {\n        const randomIndex = Math.floor(Math.random() * emptyIndices.length);\n        return emptyIndices[randomIndex];\n      }\n    }\n  }\n\n  // Get all empty squares\n  const emptyIndices = board\n    .map((square, index) => (square === null ? index : null))\n    .filter((index): index is number => index !== null);\n\n  if (emptyIndices.length === 0) {\n    return -1;\n  }\n\n  // Slightly prefer center and corners\n  const preferredMoves = [4, 0, 2, 6, 8].filter(index => board[index] === null);\n  if (preferredMoves.length > 0 && Math.random() > 0.5) {\n    const randomPreferredIndex = Math.floor(Math.random() * preferredMoves.length);\n    return preferredMoves[randomPreferredIndex];\n  }\n\n  // Otherwise pick randomly from all empty squares\n  const randomIndex = Math.floor(Math.random() * emptyIndices.length);\n  return emptyIndices[randomIndex];\n}"],"names":["MAX_MOVES_PER_PLAYER","findBestLimitedMove","board","aiPlayer","xMoves","oMoves","humanPlayer","aiMoves","humanMoves","winningMove","hasWinningMove","blockingMove","limitedModeStrategy","emptyCells","cell","index","moveToReplace","bestScore","bestMove","emptyCell","simulatedBoard","newAiMoves","score","evaluateWithLookahead","forkMove","hasForkMove","blockForkMove","depth","isGameOver","evaluateLimitedModePosition","maxScore","newBoard","oldestMove","minScore","newHumanMoves","lines","a","b","c","minimaxCache","getBoardHash","isMaximizing","findBestMove","gameStyle","difficulty","emptyIndices","square","adaptiveMove","getBayesianCounterMove","minimax","alpha","beta","cacheKey","winner","checkWinner","i","findRandomMove","randomIndex","preferredMoves","randomPreferredIndex"],"mappings":"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"}